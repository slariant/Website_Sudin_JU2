"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@imagekit";
exports.ids = ["vendor-chunks/@imagekit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@imagekit/next/dist/client/index-esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@imagekit/next/dist/client/index-esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__ Image,ImageKitAbortError,ImageKitContext,ImageKitInvalidRequestError,ImageKitProvider,ImageKitServerError,ImageKitUploadNetworkError,Video,buildSrc,buildTransformationString,getResponsiveImageAttributes,upload auto */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Image: function() {\n        return Image;\n    },\n    ImageKitAbortError: function() {\n        return ImageKitAbortError;\n    },\n    ImageKitContext: function() {\n        return ImageKitContext;\n    },\n    ImageKitInvalidRequestError: function() {\n        return ImageKitInvalidRequestError;\n    },\n    ImageKitProvider: function() {\n        return ImageKitProvider;\n    },\n    ImageKitServerError: function() {\n        return ImageKitServerError;\n    },\n    ImageKitUploadNetworkError: function() {\n        return ImageKitUploadNetworkError;\n    },\n    Video: function() {\n        return Video;\n    },\n    buildSrc: function() {\n        return buildSrc;\n    },\n    buildTransformationString: function() {\n        return buildTransformationString;\n    },\n    getResponsiveImageAttributes: function() {\n        return getResponsiveImageAttributes;\n    },\n    upload: function() {\n        return upload;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(ssr)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(ssr)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _image = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar errorMessages = {\n    MISSING_UPLOAD_FILE_PARAMETER: {\n        message: \"Missing file parameter for upload\"\n    },\n    MISSING_UPLOAD_FILENAME_PARAMETER: {\n        message: \"Missing fileName parameter for upload\"\n    },\n    MISSING_PUBLIC_KEY: {\n        message: \"Missing public key for upload\"\n    },\n    UPLOAD_ENDPOINT_NETWORK_ERROR: {\n        message: \"Request to ImageKit upload endpoint failed due to network error\"\n    },\n    MISSING_SIGNATURE: {\n        message: \"Missing signature for upload. The SDK expects token, signature and expire for authentication.\"\n    },\n    MISSING_TOKEN: {\n        message: \"Missing token for upload. The SDK expects token, signature and expire for authentication.\"\n    },\n    MISSING_EXPIRE: {\n        message: \"Missing expire for upload. The SDK expects token, signature and expire for authentication.\"\n    },\n    INVALID_TRANSFORMATION: {\n        message: \"Invalid transformation parameter. Please include at least pre, post, or both.\"\n    },\n    INVALID_PRE_TRANSFORMATION: {\n        message: \"Invalid pre transformation parameter.\"\n    },\n    INVALID_POST_TRANSFORMATION: {\n        message: \"Invalid post transformation parameter.\"\n    }\n};\nclass ImageKitInvalidRequestError extends Error {\n    constructor(message, responseMetadata){\n        super(message);\n        this.$ResponseMetadata = void 0;\n        this.name = \"ImageKitInvalidRequestError\";\n        this.$ResponseMetadata = responseMetadata;\n    }\n}\nclass ImageKitAbortError extends Error {\n    constructor(message, reason){\n        super(message);\n        this.reason = void 0;\n        this.name = \"ImageKitAbortError\";\n        this.reason = reason;\n    }\n}\nclass ImageKitUploadNetworkError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"ImageKitUploadNetworkError\";\n    }\n}\nclass ImageKitServerError extends Error {\n    constructor(message, responseMetadata){\n        super(message);\n        this.$ResponseMetadata = void 0;\n        this.name = \"ImageKitServerError\";\n        this.$ResponseMetadata = responseMetadata;\n    }\n}\nconst upload = (uploadOptions)=>{\n    if (!uploadOptions) {\n        return Promise.reject(new ImageKitInvalidRequestError(\"Invalid options provided for upload\"));\n    }\n    return new Promise((resolve, reject)=>{\n        const { xhr: userProvidedXHR } = uploadOptions || {};\n        delete uploadOptions.xhr;\n        const xhr = userProvidedXHR || new XMLHttpRequest();\n        if (!uploadOptions.file) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_UPLOAD_FILE_PARAMETER.message));\n        }\n        if (!uploadOptions.fileName) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_UPLOAD_FILENAME_PARAMETER.message));\n        }\n        if (!uploadOptions.publicKey || uploadOptions.publicKey.length === 0) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_PUBLIC_KEY.message));\n        }\n        if (!uploadOptions.token) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_TOKEN.message));\n        }\n        if (!uploadOptions.signature) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_SIGNATURE.message));\n        }\n        if (!uploadOptions.expire) {\n            return reject(new ImageKitInvalidRequestError(errorMessages.MISSING_EXPIRE.message));\n        }\n        if (uploadOptions.transformation) {\n            if (!(Object.keys(uploadOptions.transformation).includes(\"pre\") || Object.keys(uploadOptions.transformation).includes(\"post\"))) {\n                return reject(new ImageKitInvalidRequestError(errorMessages.INVALID_TRANSFORMATION.message));\n            }\n            if (Object.keys(uploadOptions.transformation).includes(\"pre\") && !uploadOptions.transformation.pre) {\n                return reject(new ImageKitInvalidRequestError(errorMessages.INVALID_PRE_TRANSFORMATION.message));\n            }\n            if (Object.keys(uploadOptions.transformation).includes(\"post\")) {\n                if (Array.isArray(uploadOptions.transformation.post)) {\n                    for (let transformation of uploadOptions.transformation.post){\n                        if (transformation.type === \"abs\" && !(transformation.protocol || transformation.value)) {\n                            return reject(new ImageKitInvalidRequestError(errorMessages.INVALID_POST_TRANSFORMATION.message));\n                        } else if (transformation.type === \"transformation\" && !transformation.value) {\n                            return reject(new ImageKitInvalidRequestError(errorMessages.INVALID_POST_TRANSFORMATION.message));\n                        }\n                    }\n                } else {\n                    return reject(new ImageKitInvalidRequestError(errorMessages.INVALID_POST_TRANSFORMATION.message));\n                }\n            }\n        }\n        var formData = new FormData();\n        let key;\n        for(key in uploadOptions){\n            if (key) {\n                if (key === \"file\" && typeof uploadOptions.file != \"string\") {\n                    formData.set(\"file\", uploadOptions.file, String(uploadOptions.fileName));\n                } else if (key === \"tags\" && Array.isArray(uploadOptions.tags)) {\n                    formData.set(\"tags\", uploadOptions.tags.join(\",\"));\n                } else if (key === \"signature\") {\n                    formData.set(\"signature\", uploadOptions.signature);\n                } else if (key === \"expire\") {\n                    formData.set(\"expire\", String(uploadOptions.expire));\n                } else if (key === \"token\") {\n                    formData.set(\"token\", uploadOptions.token);\n                } else if (key === \"responseFields\" && Array.isArray(uploadOptions.responseFields)) {\n                    formData.set(\"responseFields\", uploadOptions.responseFields.join(\",\"));\n                } else if (key === \"extensions\" && Array.isArray(uploadOptions.extensions)) {\n                    formData.set(\"extensions\", JSON.stringify(uploadOptions.extensions));\n                } else if (key === \"customMetadata\" && typeof uploadOptions.customMetadata === \"object\" && !Array.isArray(uploadOptions.customMetadata) && uploadOptions.customMetadata !== null) {\n                    formData.set(\"customMetadata\", JSON.stringify(uploadOptions.customMetadata));\n                } else if (key === \"transformation\" && typeof uploadOptions.transformation === \"object\" && uploadOptions.transformation !== null) {\n                    formData.set(key, JSON.stringify(uploadOptions.transformation));\n                } else if (key === \"checks\" && uploadOptions.checks) {\n                    formData.set(\"checks\", uploadOptions.checks);\n                } else if (uploadOptions[key] !== undefined) {\n                    if ([\n                        \"onProgress\",\n                        \"abortSignal\"\n                    ].includes(key)) continue;\n                    formData.set(key, String(uploadOptions[key]));\n                }\n            }\n        }\n        if (uploadOptions.onProgress) {\n            xhr.upload.onprogress = function(event) {\n                if (uploadOptions.onProgress) uploadOptions.onProgress(event);\n            };\n        }\n        function onAbortHandler() {\n            var _uploadOptions$abortS;\n            xhr.abort();\n            return reject(new ImageKitAbortError(\"Upload aborted\", (_uploadOptions$abortS = uploadOptions.abortSignal) === null || _uploadOptions$abortS === void 0 ? void 0 : _uploadOptions$abortS.reason));\n        }\n        if (uploadOptions.abortSignal) {\n            if (uploadOptions.abortSignal.aborted) {\n                var _uploadOptions$abortS2;\n                return reject(new ImageKitAbortError(\"Upload aborted\", (_uploadOptions$abortS2 = uploadOptions.abortSignal) === null || _uploadOptions$abortS2 === void 0 ? void 0 : _uploadOptions$abortS2.reason));\n            }\n            uploadOptions.abortSignal.addEventListener(\"abort\", onAbortHandler);\n            xhr.addEventListener(\"loadend\", ()=>{\n                if (uploadOptions.abortSignal) {\n                    uploadOptions.abortSignal.removeEventListener(\"abort\", onAbortHandler);\n                }\n            });\n        }\n        xhr.open(\"POST\", \"https://upload.imagekit.io/api/v1/files/upload\");\n        xhr.onerror = function(e) {\n            return reject(new ImageKitUploadNetworkError(errorMessages.UPLOAD_ENDPOINT_NETWORK_ERROR.message));\n        };\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                try {\n                    var body = JSON.parse(xhr.responseText);\n                    var uploadResponse = addResponseHeadersAndBody(body, xhr);\n                    return resolve(uploadResponse);\n                } catch (ex) {\n                    return reject(ex);\n                }\n            } else if (xhr.status >= 400 && xhr.status < 500) {\n                try {\n                    var body = JSON.parse(xhr.responseText);\n                    return reject(new ImageKitInvalidRequestError(body.message ?? \"Invalid request. Please check the parameters.\", getResponseMetadata(xhr)));\n                } catch (ex) {\n                    return reject(ex);\n                }\n            } else {\n                try {\n                    var body = JSON.parse(xhr.responseText);\n                    return reject(new ImageKitServerError(body.message ?? \"Server error occurred while uploading the file. This is rare and usually temporary.\", getResponseMetadata(xhr)));\n                } catch (ex) {\n                    return reject(new ImageKitServerError(\"Server error occurred while uploading the file. This is rare and usually temporary.\", getResponseMetadata(xhr)));\n                }\n            }\n        };\n        xhr.send(formData);\n    });\n};\nconst addResponseHeadersAndBody = (body, xhr)=>{\n    let response = {\n        ...body\n    };\n    const responseMetadata = getResponseMetadata(xhr);\n    Object.defineProperty(response, \"$ResponseMetadata\", {\n        value: responseMetadata,\n        enumerable: false,\n        writable: false\n    });\n    return response;\n};\nconst getResponseMetadata = (xhr)=>{\n    const headers = getResponseHeaderMap(xhr);\n    const responseMetadata = {\n        statusCode: xhr.status,\n        headers: headers,\n        requestId: headers[\"x-request-id\"]\n    };\n    return responseMetadata;\n};\nfunction getResponseHeaderMap(xhr) {\n    const headers = {};\n    const responseHeaders = xhr.getAllResponseHeaders();\n    if (Object.keys(responseHeaders).length) {\n        responseHeaders.trim().split(/[\\r\\n]+/).map((value)=>value.split(/: /)).forEach((keyValue)=>{\n            headers[keyValue[0].trim().toLowerCase()] = keyValue[1].trim();\n        });\n    }\n    return headers;\n}\nconst supportedTransforms = {\n    width: \"w\",\n    height: \"h\",\n    aspectRatio: \"ar\",\n    background: \"bg\",\n    border: \"b\",\n    crop: \"c\",\n    cropMode: \"cm\",\n    dpr: \"dpr\",\n    focus: \"fo\",\n    quality: \"q\",\n    x: \"x\",\n    xCenter: \"xc\",\n    y: \"y\",\n    yCenter: \"yc\",\n    format: \"f\",\n    videoCodec: \"vc\",\n    audioCodec: \"ac\",\n    radius: \"r\",\n    rotation: \"rt\",\n    blur: \"bl\",\n    named: \"n\",\n    defaultImage: \"di\",\n    flip: \"fl\",\n    original: \"orig\",\n    startOffset: \"so\",\n    endOffset: \"eo\",\n    duration: \"du\",\n    streamingResolutions: \"sr\",\n    grayscale: \"e-grayscale\",\n    aiUpscale: \"e-upscale\",\n    aiRetouch: \"e-retouch\",\n    aiVariation: \"e-genvar\",\n    aiDropShadow: \"e-dropshadow\",\n    aiChangeBackground: \"e-changebg\",\n    aiRemoveBackground: \"e-bgremove\",\n    aiRemoveBackgroundExternal: \"e-removedotbg\",\n    contrastStretch: \"e-contrast\",\n    shadow: \"e-shadow\",\n    sharpen: \"e-sharpen\",\n    unsharpMask: \"e-usm\",\n    gradient: \"e-gradient\",\n    progressive: \"pr\",\n    lossless: \"lo\",\n    colorProfile: \"cp\",\n    metadata: \"md\",\n    opacity: \"o\",\n    trim: \"t\",\n    zoom: \"z\",\n    page: \"pg\",\n    fontSize: \"fs\",\n    fontFamily: \"ff\",\n    fontColor: \"co\",\n    innerAlignment: \"ia\",\n    padding: \"pa\",\n    alpha: \"al\",\n    typography: \"tg\",\n    lineHeight: \"lh\",\n    fontOutline: \"fol\",\n    fontShadow: \"fsh\",\n    raw: \"raw\"\n};\nconst QUERY_TRANSFORMATION_POSITION = \"query\";\nconst CHAIN_TRANSFORM_DELIMITER = \":\";\nconst TRANSFORM_DELIMITER = \",\";\nconst TRANSFORM_KEY_VALUE_DELIMITER = \"-\";\nvar transformationUtils = {\n    addAsQueryParameter: (options)=>{\n        return options.transformationPosition === QUERY_TRANSFORMATION_POSITION;\n    },\n    getTransformKey: function(transform) {\n        if (!transform) {\n            return \"\";\n        }\n        return supportedTransforms[transform] || supportedTransforms[transform.toLowerCase()] || \"\";\n    },\n    getChainTransformDelimiter: function() {\n        return CHAIN_TRANSFORM_DELIMITER;\n    },\n    getTransformDelimiter: function() {\n        return TRANSFORM_DELIMITER;\n    },\n    getTransformKeyValueDelimiter: function() {\n        return TRANSFORM_KEY_VALUE_DELIMITER;\n    }\n};\nconst safeBtoa = function(str) {\n    if (false) {} else {\n        return Buffer.from(str, \"utf8\").toString(\"base64\");\n    }\n};\nconst TRANSFORMATION_PARAMETER = \"tr\";\nconst SIMPLE_OVERLAY_PATH_REGEX = new RegExp(\"^[a-zA-Z0-9-._/ ]*$\");\nconst SIMPLE_OVERLAY_TEXT_REGEX = new RegExp(\"^[a-zA-Z0-9-._ ]*$\");\nfunction removeTrailingSlash(str) {\n    if (typeof str == \"string\" && str[str.length - 1] == \"/\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n}\nfunction removeLeadingSlash(str) {\n    if (typeof str == \"string\" && str[0] == \"/\") {\n        str = str.slice(1);\n    }\n    return str;\n}\nfunction pathJoin(parts, sep) {\n    var separator = sep || \"/\";\n    var replace = new RegExp(separator + \"{1,}\", \"g\");\n    return parts.join(separator).replace(replace, separator);\n}\nconst buildSrc = (opts)=>{\n    opts.urlEndpoint = opts.urlEndpoint || \"\";\n    opts.src = opts.src || \"\";\n    opts.transformationPosition = opts.transformationPosition || \"query\";\n    if (!opts.src) {\n        return \"\";\n    }\n    const isAbsoluteURL = opts.src.startsWith(\"http://\") || opts.src.startsWith(\"https://\");\n    var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;\n    try {\n        if (!isAbsoluteURL) {\n            urlEndpointPattern = new URL(opts.urlEndpoint).pathname;\n            urlObj = new URL(pathJoin([\n                opts.urlEndpoint.replace(urlEndpointPattern, \"\"),\n                opts.src\n            ]));\n        } else {\n            urlObj = new URL(opts.src);\n            isSrcParameterUsedForURL = true;\n        }\n    } catch (e) {\n        console.error(e);\n        return \"\";\n    }\n    for(var i in opts.queryParameters){\n        urlObj.searchParams.append(i, String(opts.queryParameters[i]));\n    }\n    var transformationString = buildTransformationString(opts.transformation);\n    if (transformationString && transformationString.length) {\n        if (!transformationUtils.addAsQueryParameter(opts) && !isSrcParameterUsedForURL) {\n            urlObj.pathname = pathJoin([\n                TRANSFORMATION_PARAMETER + transformationUtils.getChainTransformDelimiter() + transformationString,\n                urlObj.pathname\n            ]);\n        }\n    }\n    if (urlEndpointPattern) {\n        urlObj.pathname = pathJoin([\n            urlEndpointPattern,\n            urlObj.pathname\n        ]);\n    } else {\n        urlObj.pathname = pathJoin([\n            urlObj.pathname\n        ]);\n    }\n    if (transformationString && transformationString.length) {\n        if (transformationUtils.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {\n            if (urlObj.searchParams.toString() !== \"\") {\n                return `${urlObj.href}&${TRANSFORMATION_PARAMETER}=${transformationString}`;\n            } else {\n                return `${urlObj.href}?${TRANSFORMATION_PARAMETER}=${transformationString}`;\n            }\n        }\n    }\n    return urlObj.href;\n};\nfunction processInputPath(str, enccoding) {\n    str = removeTrailingSlash(removeLeadingSlash(str));\n    if (enccoding === \"plain\") {\n        return `i-${str.replace(/\\//g, \"@@\")}`;\n    }\n    if (enccoding === \"base64\") {\n        return `ie-${encodeURIComponent(safeBtoa(str))}`;\n    }\n    if (SIMPLE_OVERLAY_PATH_REGEX.test(str)) {\n        return `i-${str.replace(/\\//g, \"@@\")}`;\n    } else {\n        return `ie-${encodeURIComponent(safeBtoa(str))}`;\n    }\n}\nfunction processText(str, enccoding) {\n    if (enccoding === \"plain\") {\n        return `i-${encodeURIComponent(str)}`;\n    }\n    if (enccoding === \"base64\") {\n        return `ie-${encodeURIComponent(safeBtoa(str))}`;\n    }\n    if (SIMPLE_OVERLAY_TEXT_REGEX.test(str)) {\n        return `i-${encodeURIComponent(str)}`;\n    }\n    return `ie-${encodeURIComponent(safeBtoa(str))}`;\n}\nfunction processOverlay(overlay) {\n    const entries = [];\n    const { type, position = {}, timing = {}, transformation = [] } = overlay || {};\n    if (!type) {\n        return;\n    }\n    switch(type){\n        case \"text\":\n            {\n                const textOverlay = overlay;\n                if (!textOverlay.text) {\n                    return;\n                }\n                const enccoding = textOverlay.encoding || \"auto\";\n                entries.push(\"l-text\");\n                entries.push(processText(textOverlay.text, enccoding));\n            }\n            break;\n        case \"image\":\n            entries.push(\"l-image\");\n            {\n                const imageOverlay = overlay;\n                const enccoding = imageOverlay.encoding || \"auto\";\n                if (imageOverlay.input) {\n                    entries.push(processInputPath(imageOverlay.input, enccoding));\n                } else {\n                    return;\n                }\n            }\n            break;\n        case \"video\":\n            entries.push(\"l-video\");\n            {\n                const videoOverlay = overlay;\n                const enccoding = videoOverlay.encoding || \"auto\";\n                if (videoOverlay.input) {\n                    entries.push(processInputPath(videoOverlay.input, enccoding));\n                } else {\n                    return;\n                }\n            }\n            break;\n        case \"subtitle\":\n            entries.push(\"l-subtitle\");\n            {\n                const subtitleOverlay = overlay;\n                const enccoding = subtitleOverlay.encoding || \"auto\";\n                if (subtitleOverlay.input) {\n                    entries.push(processInputPath(subtitleOverlay.input, enccoding));\n                } else {\n                    return;\n                }\n            }\n            break;\n        case \"solidColor\":\n            entries.push(\"l-image\");\n            entries.push(`i-ik_canvas`);\n            {\n                const solidColorOverlay = overlay;\n                if (solidColorOverlay.color) {\n                    entries.push(`bg-${solidColorOverlay.color}`);\n                } else {\n                    return;\n                }\n            }\n            break;\n    }\n    const { x, y, focus } = position;\n    if (x) {\n        entries.push(`lx-${x}`);\n    }\n    if (y) {\n        entries.push(`ly-${y}`);\n    }\n    if (focus) {\n        entries.push(`lfo-${focus}`);\n    }\n    const { start, end, duration } = timing;\n    if (start) {\n        entries.push(`lso-${start}`);\n    }\n    if (end) {\n        entries.push(`leo-${end}`);\n    }\n    if (duration) {\n        entries.push(`ldu-${duration}`);\n    }\n    const transformationString = buildTransformationString(transformation);\n    if (transformationString && transformationString.trim() !== \"\") entries.push(transformationString);\n    entries.push(\"l-end\");\n    return entries.join(transformationUtils.getTransformDelimiter());\n}\nconst buildTransformationString = function(transformation) {\n    if (!Array.isArray(transformation)) {\n        return \"\";\n    }\n    var parsedTransforms = [];\n    for(var i = 0, l = transformation.length; i < l; i++){\n        var parsedTransformStep = [];\n        for(var key in transformation[i]){\n            let value = transformation[i][key];\n            if (value === undefined || value === null) {\n                continue;\n            }\n            if (key === \"overlay\" && typeof value === \"object\") {\n                var rawString = processOverlay(value);\n                if (rawString && rawString.trim() !== \"\") {\n                    parsedTransformStep.push(rawString);\n                }\n                continue;\n            }\n            var transformKey = transformationUtils.getTransformKey(key);\n            if (!transformKey) {\n                transformKey = key;\n            }\n            if (transformKey === \"\") {\n                continue;\n            }\n            if ([\n                \"e-grayscale\",\n                \"e-contrast\",\n                \"e-removedotbg\",\n                \"e-bgremove\",\n                \"e-upscale\",\n                \"e-retouch\",\n                \"e-genvar\"\n            ].includes(transformKey)) {\n                if (value === true || value === \"-\" || value === \"true\") {\n                    parsedTransformStep.push(transformKey);\n                } else {\n                    continue;\n                }\n            } else if ([\n                \"e-sharpen\",\n                \"e-shadow\",\n                \"e-gradient\",\n                \"e-usm\",\n                \"e-dropshadow\"\n            ].includes(transformKey) && (value.toString().trim() === \"\" || value === true || value === \"true\")) {\n                parsedTransformStep.push(transformKey);\n            } else if (key === \"raw\") {\n                parsedTransformStep.push(transformation[i][key]);\n            } else {\n                if (transformKey === \"di\") {\n                    value = removeTrailingSlash(removeLeadingSlash(value || \"\"));\n                    value = value.replace(/\\//g, \"@@\");\n                }\n                if (transformKey === \"sr\" && Array.isArray(value)) {\n                    value = value.join(\"_\");\n                }\n                if (transformKey === \"t\" && value.toString().trim() === \"\") {\n                    value = \"true\";\n                }\n                parsedTransformStep.push([\n                    transformKey,\n                    value\n                ].join(transformationUtils.getTransformKeyValueDelimiter()));\n            }\n        }\n        if (parsedTransformStep.length) {\n            parsedTransforms.push(parsedTransformStep.join(transformationUtils.getTransformDelimiter()));\n        }\n    }\n    return parsedTransforms.join(transformationUtils.getChainTransformDelimiter());\n};\nconst DEFAULT_DEVICE_BREAKPOINTS = [\n    640,\n    750,\n    828,\n    1080,\n    1200,\n    1920,\n    2048,\n    3840\n];\nconst DEFAULT_IMAGE_BREAKPOINTS = [\n    16,\n    32,\n    48,\n    64,\n    96,\n    128,\n    256,\n    384\n];\nfunction getResponsiveImageAttributes(opts) {\n    const { src, urlEndpoint, transformation = [], queryParameters, transformationPosition, sizes, width, deviceBreakpoints = DEFAULT_DEVICE_BREAKPOINTS, imageBreakpoints = DEFAULT_IMAGE_BREAKPOINTS } = opts;\n    const sortedDeviceBreakpoints = [\n        ...deviceBreakpoints\n    ].sort((a, b)=>a - b);\n    const sortedImageBreakpoints = [\n        ...imageBreakpoints\n    ].sort((a, b)=>a - b);\n    const allBreakpoints = [\n        ...sortedImageBreakpoints,\n        ...sortedDeviceBreakpoints\n    ].sort((a, b)=>a - b);\n    const { candidates, descriptorKind } = computeCandidateWidths({\n        allBreakpoints,\n        deviceBreakpoints: sortedDeviceBreakpoints,\n        explicitWidth: width,\n        sizesAttr: sizes\n    });\n    const buildURL = (w)=>buildSrc({\n            src,\n            urlEndpoint,\n            queryParameters,\n            transformationPosition,\n            transformation: [\n                ...transformation,\n                {\n                    width: w,\n                    crop: \"at_max\"\n                }\n            ]\n        });\n    const srcSet = candidates.map((w, i)=>`${buildURL(w)} ${descriptorKind === \"w\" ? w : i + 1}${descriptorKind}`).join(\", \") || undefined;\n    const finalSizes = sizes ?? (descriptorKind === \"w\" ? \"100vw\" : undefined);\n    return {\n        src: buildURL(candidates[candidates.length - 1]),\n        srcSet,\n        ...finalSizes ? {\n            sizes: finalSizes\n        } : {},\n        ...width !== undefined ? {\n            width\n        } : {}\n    };\n}\nfunction computeCandidateWidths(params) {\n    const { allBreakpoints, deviceBreakpoints, explicitWidth, sizesAttr } = params;\n    if (sizesAttr) {\n        const vwTokens = sizesAttr.match(/(^|\\s)(1?\\d{1,2})vw/g) || [];\n        const vwPercents = vwTokens.map((t)=>parseInt(t, 10));\n        if (vwPercents.length) {\n            const smallestRatio = Math.min(...vwPercents) / 100;\n            const minRequiredPx = deviceBreakpoints[0] * smallestRatio;\n            return {\n                candidates: allBreakpoints.filter((w)=>w >= minRequiredPx),\n                descriptorKind: \"w\"\n            };\n        }\n        return {\n            candidates: allBreakpoints,\n            descriptorKind: \"w\"\n        };\n    }\n    if (typeof explicitWidth !== \"number\") {\n        return {\n            candidates: deviceBreakpoints,\n            descriptorKind: \"w\"\n        };\n    }\n    const nearest = (t)=>allBreakpoints.find((n)=>n >= t) || allBreakpoints[allBreakpoints.length - 1];\n    const unique = Array.from(new Set([\n        nearest(explicitWidth),\n        nearest(explicitWidth * 2)\n    ]));\n    return {\n        candidates: unique,\n        descriptorKind: \"x\"\n    };\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst ImageKitContext = /*#__PURE__*/ (0, _react.createContext)({});\n/**\n * You can use the `ImageKitProvider` component to set the default values for all nested Image and Video components provided by the SDK.\n *\n * It accepts the following props:\n * - `urlEndpoint`: The URL endpoint for your ImageKit account. You can get this from the [ImageKit dashboard](https://imagekit.io/dashboard/url-endpoints).\n * - `transformationPosition`: The position of the transformation string in the URL. It can be either `path` or `query`. By default, it is set to `query`.\n *\n * @example\n * ```jsx\n * import { ImageKitProvider, Image } from \"@imagekit/next\";\n * <ImageKitProvider urlEndpoint=\"https://ik.imagekit.io/your_imagekit_id\">\n *   <Image src=\"/default-image.jpg\" />\n * </ImageKitProvider>\n * ```\n */ const ImageKitProvider = (props)=>{\n    const { urlEndpoint, transformationPosition } = props;\n    return /*#__PURE__*/ _react.default.createElement(ImageKitContext.Provider, {\n        value: {\n            urlEndpoint,\n            transformationPosition\n        }\n    }, props.children);\n};\n/**\n * The Image component is a wrapper around the Next.js Image component. It supports all the features of the Next.js Image component, along with additional features provided by ImageKit.\n *\n * @example\n * ```jsx\n * import { Image } from \"@imagekit/next\";\n * <Image\n *  urlEndpoint=\"https://ik.imagekit.io/your_imagekit_id\" // You can also set this in a parent ImageKitProvider component\n *  src=\"/default-image.jpg\" // The path to the image in your ImageKit account\n *  alt=\"Default Image\"\n *  width={500}\n *  height={500}\n *  transformation={[{ width: 500, height: 500 }]} // Add ImageKit transformations\n * />\n * ```\n */ const Image = (props)=>{\n    if (props.loader) {\n        if (true) {\n            console.warn(\"loader prop is ignored by ImageKit Image component.\");\n        }\n    }\n    const contextValues = (0, _react.useContext)(ImageKitContext);\n    // Its important to extract the ImageKit specific props from the props, so that we can use the rest of the props as is in the NextImage component\n    const _a = Object.assign(Object.assign({}, contextValues), props // Override with props\n    ), { transformation = [], unoptimized = false, quality, src = \"\", queryParameters, urlEndpoint, transformationPosition, responsive = true, loader } = _a, nonIKParams = __rest(_a, [\n        \"transformation\",\n        \"unoptimized\",\n        \"quality\",\n        \"src\",\n        \"queryParameters\",\n        \"urlEndpoint\",\n        \"transformationPosition\",\n        \"responsive\",\n        \"loader\"\n    ]);\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n        if (true) {\n            console.error(\"urlEndpoint is neither provided in this component nor in the ImageKitContext.\");\n        }\n        return null;\n    }\n    const isAbsoluteURL = src.startsWith(\"http://\") || src.startsWith(\"https://\");\n    // Do not mutate original transformation array from the props\n    const finalTransformation = [\n        ...transformation\n    ];\n    let propsTransformation = {};\n    if (quality) {\n        const parsedQuality = Number(quality);\n        if (!isNaN(parsedQuality)) {\n            propsTransformation.quality = parsedQuality;\n        } else {\n            if (true) {\n                console.error(\"Invalid quality value, skipping transformation.\");\n            }\n        }\n    }\n    // Return original file without any transformation or optimization to match the behavior of NextImage\n    // Always keep src in the end\n    if (unoptimized) {\n        return /*#__PURE__*/ _react.default.createElement(_image.default, Object.assign({\n            unoptimized: true\n        }, nonIKParams, {\n            src: buildSrc({\n                urlEndpoint,\n                src,\n                queryParameters,\n                transformationPosition,\n                transformation: [\n                    {\n                        \"raw\": \"orig-true\"\n                    }\n                ]\n            })\n        }));\n    }\n    // User disabled responsive images\n    if (!responsive) {\n        return /*#__PURE__*/ _react.default.createElement(_image.default, Object.assign({\n            unoptimized: true\n        }, nonIKParams, {\n            src: buildSrc({\n                urlEndpoint,\n                src,\n                queryParameters,\n                transformationPosition,\n                // keep only userâ€‘supplied transformations;no width, no crop\n                transformation: [\n                    ...finalTransformation,\n                    Object.assign({}, propsTransformation)\n                ]\n            })\n        }));\n    }\n    // Don't pass transformation just yet as loader will take care of it along with width for srcset generation as per Next.js logic.\n    const finalSrcWithoutTransformation = buildSrc({\n        urlEndpoint,\n        queryParameters,\n        src\n    });\n    return(// Always keep src in the end\n    /*#__PURE__*/ _react.default.createElement(_image.default, Object.assign({\n        loader: ({ src, width })=>{\n            // Since `src` inside loader is always absolute, `buildSrc` won't respect the `path` transformation position.\n            // To fix this, if the original src prop isn't an absolute URL, remove `urlEndpoint` from this `src`\n            // before calling `buildSrc`. Otherwise, leave it as is.\n            const srcWithoutUrlEndpoint = !isAbsoluteURL ? src.replace(urlEndpoint, \"\") : src;\n            const finalSrc = buildSrc({\n                urlEndpoint,\n                src: srcWithoutUrlEndpoint,\n                transformationPosition,\n                transformation: [\n                    ...finalTransformation,\n                    Object.assign(Object.assign({}, propsTransformation), {\n                        width,\n                        crop: \"at_max\"\n                    })\n                ]\n            });\n            return finalSrc;\n        }\n    }, nonIKParams, {\n        src: finalSrcWithoutTransformation\n    })));\n};\n/**\n * The Video component is a wrapper around the HTML video element. It supports all the features of the HTML video element, along with additional features provided by ImageKit.\n *\n * @example\n * ```jsx\n * import { Video } from \"@imagekit/next\";\n * <Video\n *  urlEndpoint=\"https://ik.imagekit.io/your_imagekit_id\" // You can also set this in a parent ImageKitProvider component\n *  src=\"/default-video.mp4\" // The path to the video in your ImageKit account\n *  controls\n *  width={500}\n *  height={500}\n *  transformation={[{ width: 500, height: 500 }]} // Add ImageKit transformations\n * />\n * ```\n */ const Video = (props)=>{\n    const contextValues = (0, _react.useContext)(ImageKitContext);\n    // Its important to extract the ImageKit specific props from the props, so that we can use the rest of the props as is in the video element\n    const _a = Object.assign(Object.assign({}, contextValues), props // Override with props\n    ), { transformation = [], src = \"\", queryParameters, urlEndpoint, transformationPosition } = _a, nonIKParams = __rest(_a, [\n        \"transformation\",\n        \"src\",\n        \"queryParameters\",\n        \"urlEndpoint\",\n        \"transformationPosition\"\n    ]);\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n        if (true) {\n            console.error(\"urlEndpoint is neither provided in this component nor in the ImageKitContext.\");\n        }\n        return null;\n    }\n    const finalSrc = buildSrc({\n        urlEndpoint,\n        src,\n        transformation: [\n            ...transformation\n        ],\n        // Do not mutate original transformation array from the props\n        queryParameters,\n        transformationPosition\n    });\n    return /*#__PURE__*/ _react.default.createElement(\"video\", Object.assign({}, nonIKParams, {\n        src: finalSrc\n    }));\n};\n //# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGltYWdla2l0L25leHQvZGlzdC9jbGllbnQvaW5kZXgtZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBcTRCU0EsS0FBSztlQUFMQTs7SUFBT0Msa0JBQWtCO2VBQWxCQTs7SUFBb0JDLGVBQWU7ZUFBZkE7O0lBQWlCQywyQkFBMkI7ZUFBM0JBOztJQUE2QkMsZ0JBQWdCO2VBQWhCQTs7SUFBa0JDLG1CQUFtQjtlQUFuQkE7O0lBQXFCQywwQkFBMEI7ZUFBMUJBOztJQUE0QkMsS0FBSztlQUFMQTs7SUFBT0MsUUFBUTtlQUFSQTs7SUFBVUMseUJBQXlCO2VBQXpCQTs7SUFBMkJDLDRCQUE0QjtlQUE1QkE7O0lBQThCQyxNQUFNO2VBQU5BOzs7Ozs0RUFwNEJ6TTs2RUFDMkI7QUFFakQsSUFBSUMsZ0JBQWdCO0lBQ2xCQywrQkFBK0I7UUFDN0JDLFNBQVM7SUFDWDtJQUNBQyxtQ0FBbUM7UUFDakNELFNBQVM7SUFDWDtJQUNBRSxvQkFBb0I7UUFDbEJGLFNBQVM7SUFDWDtJQUNBRywrQkFBK0I7UUFDN0JILFNBQVM7SUFDWDtJQUNBSSxtQkFBbUI7UUFDakJKLFNBQVM7SUFDWDtJQUNBSyxlQUFlO1FBQ2JMLFNBQVM7SUFDWDtJQUNBTSxnQkFBZ0I7UUFDZE4sU0FBUztJQUNYO0lBQ0FPLHdCQUF3QjtRQUN0QlAsU0FBUztJQUNYO0lBQ0FRLDRCQUE0QjtRQUMxQlIsU0FBUztJQUNYO0lBQ0FTLDZCQUE2QjtRQUMzQlQsU0FBUztJQUNYO0FBQ0Y7QUFFQSxNQUFNWCxvQ0FBb0NxQjtJQUN4Q0MsWUFBWVgsT0FBTyxFQUFFWSxnQkFBZ0IsQ0FBRTtRQUNyQyxLQUFLLENBQUNaO1FBQ04sSUFBSSxDQUFDYSxpQkFBaUIsR0FBRyxLQUFLO1FBQzlCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxpQkFBaUIsR0FBR0Q7SUFDM0I7QUFDRjtBQUNBLE1BQU16QiwyQkFBMkJ1QjtJQUMvQkMsWUFBWVgs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QUFHRyxhQUFhO1FBQ2pFekcsS0FBS2tIO0lBQ1A7QUFDRjtDQUdBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1ZGluLXBlbmRpZGlrYW4tbmV4dC8uL25vZGVfbW9kdWxlcy9AaW1hZ2VraXQvbmV4dC9kaXN0L2NsaWVudC9pbmRleC1lc20uanM/NjUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCBOZXh0SW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gIE1JU1NJTkdfVVBMT0FEX0ZJTEVfUEFSQU1FVEVSOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIGZpbGUgcGFyYW1ldGVyIGZvciB1cGxvYWRcIlxuICB9LFxuICBNSVNTSU5HX1VQTE9BRF9GSUxFTkFNRV9QQVJBTUVURVI6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZmlsZU5hbWUgcGFyYW1ldGVyIGZvciB1cGxvYWRcIlxuICB9LFxuICBNSVNTSU5HX1BVQkxJQ19LRVk6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgcHVibGljIGtleSBmb3IgdXBsb2FkXCJcbiAgfSxcbiAgVVBMT0FEX0VORFBPSU5UX05FVFdPUktfRVJST1I6IHtcbiAgICBtZXNzYWdlOiBcIlJlcXVlc3QgdG8gSW1hZ2VLaXQgdXBsb2FkIGVuZHBvaW50IGZhaWxlZCBkdWUgdG8gbmV0d29yayBlcnJvclwiXG4gIH0sXG4gIE1JU1NJTkdfU0lHTkFUVVJFOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIHNpZ25hdHVyZSBmb3IgdXBsb2FkLiBUaGUgU0RLIGV4cGVjdHMgdG9rZW4sIHNpZ25hdHVyZSBhbmQgZXhwaXJlIGZvciBhdXRoZW50aWNhdGlvbi5cIlxuICB9LFxuICBNSVNTSU5HX1RPS0VOOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIHRva2VuIGZvciB1cGxvYWQuIFRoZSBTREsgZXhwZWN0cyB0b2tlbiwgc2lnbmF0dXJlIGFuZCBleHBpcmUgZm9yIGF1dGhlbnRpY2F0aW9uLlwiXG4gIH0sXG4gIE1JU1NJTkdfRVhQSVJFOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGlyZSBmb3IgdXBsb2FkLiBUaGUgU0RLIGV4cGVjdHMgdG9rZW4sIHNpZ25hdHVyZSBhbmQgZXhwaXJlIGZvciBhdXRoZW50aWNhdGlvbi5cIlxuICB9LFxuICBJTlZBTElEX1RSQU5TRk9STUFUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlci4gUGxlYXNlIGluY2x1ZGUgYXQgbGVhc3QgcHJlLCBwb3N0LCBvciBib3RoLlwiXG4gIH0sXG4gIElOVkFMSURfUFJFX1RSQU5TRk9STUFUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHByZSB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXIuXCJcbiAgfSxcbiAgSU5WQUxJRF9QT1NUX1RSQU5TRk9STUFUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHBvc3QgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyLlwiXG4gIH1cbn07XG5cbmNsYXNzIEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2VNZXRhZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuJFJlc3BvbnNlTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gXCJJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3JcIjtcbiAgICB0aGlzLiRSZXNwb25zZU1ldGFkYXRhID0gcmVzcG9uc2VNZXRhZGF0YTtcbiAgfVxufVxuY2xhc3MgSW1hZ2VLaXRBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnJlYXNvbiA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSBcIkltYWdlS2l0QWJvcnRFcnJvclwiO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59XG5jbGFzcyBJbWFnZUtpdFVwbG9hZE5ldHdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSW1hZ2VLaXRVcGxvYWROZXR3b3JrRXJyb3JcIjtcbiAgfVxufVxuY2xhc3MgSW1hZ2VLaXRTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2VNZXRhZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuJFJlc3BvbnNlTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gXCJJbWFnZUtpdFNlcnZlckVycm9yXCI7XG4gICAgdGhpcy4kUmVzcG9uc2VNZXRhZGF0YSA9IHJlc3BvbnNlTWV0YWRhdGE7XG4gIH1cbn1cbmNvbnN0IHVwbG9hZCA9IHVwbG9hZE9wdGlvbnMgPT4ge1xuICBpZiAoIXVwbG9hZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihcIkludmFsaWQgb3B0aW9ucyBwcm92aWRlZCBmb3IgdXBsb2FkXCIpKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHhocjogdXNlclByb3ZpZGVkWEhSXG4gICAgfSA9IHVwbG9hZE9wdGlvbnMgfHwge307XG4gICAgZGVsZXRlIHVwbG9hZE9wdGlvbnMueGhyO1xuICAgIGNvbnN0IHhociA9IHVzZXJQcm92aWRlZFhIUiB8fCBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBpZiAoIXVwbG9hZE9wdGlvbnMuZmlsZSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRJbnZhbGlkUmVxdWVzdEVycm9yKGVycm9yTWVzc2FnZXMuTUlTU0lOR19VUExPQURfRklMRV9QQVJBTUVURVIubWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAoIXVwbG9hZE9wdGlvbnMuZmlsZU5hbWUpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihlcnJvck1lc3NhZ2VzLk1JU1NJTkdfVVBMT0FEX0ZJTEVOQU1FX1BBUkFNRVRFUi5tZXNzYWdlKSk7XG4gICAgfVxuICAgIGlmICghdXBsb2FkT3B0aW9ucy5wdWJsaWNLZXkgfHwgdXBsb2FkT3B0aW9ucy5wdWJsaWNLZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3IoZXJyb3JNZXNzYWdlcy5NSVNTSU5HX1BVQkxJQ19LRVkubWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAoIXVwbG9hZE9wdGlvbnMudG9rZW4pIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihlcnJvck1lc3NhZ2VzLk1JU1NJTkdfVE9LRU4ubWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAoIXVwbG9hZE9wdGlvbnMuc2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3IoZXJyb3JNZXNzYWdlcy5NSVNTSU5HX1NJR05BVFVSRS5tZXNzYWdlKSk7XG4gICAgfVxuICAgIGlmICghdXBsb2FkT3B0aW9ucy5leHBpcmUpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihlcnJvck1lc3NhZ2VzLk1JU1NJTkdfRVhQSVJFLm1lc3NhZ2UpKTtcbiAgICB9XG4gICAgaWYgKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGlmICghKE9iamVjdC5rZXlzKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pLmluY2x1ZGVzKFwicHJlXCIpIHx8IE9iamVjdC5rZXlzKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pLmluY2x1ZGVzKFwicG9zdFwiKSkpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRJbnZhbGlkUmVxdWVzdEVycm9yKGVycm9yTWVzc2FnZXMuSU5WQUxJRF9UUkFOU0ZPUk1BVElPTi5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXModXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbikuaW5jbHVkZXMoXCJwcmVcIikgJiYgIXVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHJlKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihlcnJvck1lc3NhZ2VzLklOVkFMSURfUFJFX1RSQU5TRk9STUFUSU9OLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKS5pbmNsdWRlcyhcInBvc3RcIikpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wb3N0KSkge1xuICAgICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWF0aW9uIG9mIHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24ucG9zdCkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uLnR5cGUgPT09IFwiYWJzXCIgJiYgISh0cmFuc2Zvcm1hdGlvbi5wcm90b2NvbCB8fCB0cmFuc2Zvcm1hdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRJbnZhbGlkUmVxdWVzdEVycm9yKGVycm9yTWVzc2FnZXMuSU5WQUxJRF9QT1NUX1RSQU5TRk9STUFUSU9OLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtYXRpb24udHlwZSA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiICYmICF0cmFuc2Zvcm1hdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3IoZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT04ubWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3IoZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT04ubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gdXBsb2FkT3B0aW9ucykge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImZpbGVcIiAmJiB0eXBlb2YgdXBsb2FkT3B0aW9ucy5maWxlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoJ2ZpbGUnLCB1cGxvYWRPcHRpb25zLmZpbGUsIFN0cmluZyh1cGxvYWRPcHRpb25zLmZpbGVOYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIiAmJiBBcnJheS5pc0FycmF5KHVwbG9hZE9wdGlvbnMudGFncykpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoJ3RhZ3MnLCB1cGxvYWRPcHRpb25zLnRhZ3Muam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NpZ25hdHVyZScpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoXCJzaWduYXR1cmVcIiwgdXBsb2FkT3B0aW9ucy5zaWduYXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4cGlyZScpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoXCJleHBpcmVcIiwgU3RyaW5nKHVwbG9hZE9wdGlvbnMuZXhwaXJlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndG9rZW4nKSB7XG4gICAgICAgICAgZm9ybURhdGEuc2V0KFwidG9rZW5cIiwgdXBsb2FkT3B0aW9ucy50b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJlc3BvbnNlRmllbGRzXCIgJiYgQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLnJlc3BvbnNlRmllbGRzKSkge1xuICAgICAgICAgIGZvcm1EYXRhLnNldCgncmVzcG9uc2VGaWVsZHMnLCB1cGxvYWRPcHRpb25zLnJlc3BvbnNlRmllbGRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZXh0ZW5zaW9uc1wiICYmIEFycmF5LmlzQXJyYXkodXBsb2FkT3B0aW9ucy5leHRlbnNpb25zKSkge1xuICAgICAgICAgIGZvcm1EYXRhLnNldCgnZXh0ZW5zaW9ucycsIEpTT04uc3RyaW5naWZ5KHVwbG9hZE9wdGlvbnMuZXh0ZW5zaW9ucykpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJjdXN0b21NZXRhZGF0YVwiICYmIHR5cGVvZiB1cGxvYWRPcHRpb25zLmN1c3RvbU1ldGFkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEpICYmIHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoJ2N1c3RvbU1ldGFkYXRhJywgSlNPTi5zdHJpbmdpZnkodXBsb2FkT3B0aW9ucy5jdXN0b21NZXRhZGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiICYmIHR5cGVvZiB1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uID09PSBcIm9iamVjdFwiICYmIHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBmb3JtRGF0YS5zZXQoa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2hlY2tzJyAmJiB1cGxvYWRPcHRpb25zLmNoZWNrcykge1xuICAgICAgICAgIGZvcm1EYXRhLnNldChcImNoZWNrc1wiLCB1cGxvYWRPcHRpb25zLmNoZWNrcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodXBsb2FkT3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoW1wib25Qcm9ncmVzc1wiLCBcImFib3J0U2lnbmFsXCJdLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGZvcm1EYXRhLnNldChrZXksIFN0cmluZyh1cGxvYWRPcHRpb25zW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBsb2FkT3B0aW9ucy5vblByb2dyZXNzKSB7XG4gICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHVwbG9hZE9wdGlvbnMub25Qcm9ncmVzcykgdXBsb2FkT3B0aW9ucy5vblByb2dyZXNzKGV2ZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWJvcnRIYW5kbGVyKCkge1xuICAgICAgdmFyIF91cGxvYWRPcHRpb25zJGFib3J0UztcbiAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRBYm9ydEVycm9yKFwiVXBsb2FkIGFib3J0ZWRcIiwgKF91cGxvYWRPcHRpb25zJGFib3J0UyA9IHVwbG9hZE9wdGlvbnMuYWJvcnRTaWduYWwpID09PSBudWxsIHx8IF91cGxvYWRPcHRpb25zJGFib3J0UyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3VwbG9hZE9wdGlvbnMkYWJvcnRTLnJlYXNvbikpO1xuICAgIH1cbiAgICBpZiAodXBsb2FkT3B0aW9ucy5hYm9ydFNpZ25hbCkge1xuICAgICAgaWYgKHVwbG9hZE9wdGlvbnMuYWJvcnRTaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB2YXIgX3VwbG9hZE9wdGlvbnMkYWJvcnRTMjtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRBYm9ydEVycm9yKFwiVXBsb2FkIGFib3J0ZWRcIiwgKF91cGxvYWRPcHRpb25zJGFib3J0UzIgPSB1cGxvYWRPcHRpb25zLmFib3J0U2lnbmFsKSA9PT0gbnVsbCB8fCBfdXBsb2FkT3B0aW9ucyRhYm9ydFMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdXBsb2FkT3B0aW9ucyRhYm9ydFMyLnJlYXNvbikpO1xuICAgICAgfVxuICAgICAgdXBsb2FkT3B0aW9ucy5hYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydEhhbmRsZXIpO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZW5kXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHVwbG9hZE9wdGlvbnMuYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICB1cGxvYWRPcHRpb25zLmFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB4aHIub3BlbignUE9TVCcsICdodHRwczovL3VwbG9hZC5pbWFnZWtpdC5pby9hcGkvdjEvZmlsZXMvdXBsb2FkJyk7XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRVcGxvYWROZXR3b3JrRXJyb3IoZXJyb3JNZXNzYWdlcy5VUExPQURfRU5EUE9JTlRfTkVUV09SS19FUlJPUi5tZXNzYWdlKSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgdmFyIHVwbG9hZFJlc3BvbnNlID0gYWRkUmVzcG9uc2VIZWFkZXJzQW5kQm9keShib2R5LCB4aHIpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHVwbG9hZFJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0SW52YWxpZFJlcXVlc3RFcnJvcihib2R5Lm1lc3NhZ2UgPz8gXCJJbnZhbGlkIHJlcXVlc3QuIFBsZWFzZSBjaGVjayB0aGUgcGFyYW1ldGVycy5cIiwgZ2V0UmVzcG9uc2VNZXRhZGF0YSh4aHIpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEltYWdlS2l0U2VydmVyRXJyb3IoYm9keS5tZXNzYWdlID8/IFwiU2VydmVyIGVycm9yIG9jY3VycmVkIHdoaWxlIHVwbG9hZGluZyB0aGUgZmlsZS4gVGhpcyBpcyByYXJlIGFuZCB1c3VhbGx5IHRlbXBvcmFyeS5cIiwgZ2V0UmVzcG9uc2VNZXRhZGF0YSh4aHIpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgSW1hZ2VLaXRTZXJ2ZXJFcnJvcihcIlNlcnZlciBlcnJvciBvY2N1cnJlZCB3aGlsZSB1cGxvYWRpbmcgdGhlIGZpbGUuIFRoaXMgaXMgcmFyZSBhbmQgdXN1YWxseSB0ZW1wb3JhcnkuXCIsIGdldFJlc3BvbnNlTWV0YWRhdGEoeGhyKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gIH0pO1xufTtcbmNvbnN0IGFkZFJlc3BvbnNlSGVhZGVyc0FuZEJvZHkgPSAoYm9keSwgeGhyKSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHtcbiAgICAuLi5ib2R5XG4gIH07XG4gIGNvbnN0IHJlc3BvbnNlTWV0YWRhdGEgPSBnZXRSZXNwb25zZU1ldGFkYXRhKHhocik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgXCIkUmVzcG9uc2VNZXRhZGF0YVwiLCB7XG4gICAgdmFsdWU6IHJlc3BvbnNlTWV0YWRhdGEsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgZ2V0UmVzcG9uc2VNZXRhZGF0YSA9IHhociA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSBnZXRSZXNwb25zZUhlYWRlck1hcCh4aHIpO1xuICBjb25zdCByZXNwb25zZU1ldGFkYXRhID0ge1xuICAgIHN0YXR1c0NvZGU6IHhoci5zdGF0dXMsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICByZXF1ZXN0SWQ6IGhlYWRlcnNbXCJ4LXJlcXVlc3QtaWRcIl1cbiAgfTtcbiAgcmV0dXJuIHJlc3BvbnNlTWV0YWRhdGE7XG59O1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXJNYXAoeGhyKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICBpZiAoT2JqZWN0LmtleXMocmVzcG9uc2VIZWFkZXJzKS5sZW5ndGgpIHtcbiAgICByZXNwb25zZUhlYWRlcnMudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAodmFsdWUgPT4gdmFsdWUuc3BsaXQoLzogLykpLmZvckVhY2goa2V5VmFsdWUgPT4ge1xuICAgICAgaGVhZGVyc1trZXlWYWx1ZVswXS50cmltKCkudG9Mb3dlckNhc2UoKV0gPSBrZXlWYWx1ZVsxXS50cmltKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbmNvbnN0IHN1cHBvcnRlZFRyYW5zZm9ybXMgPSB7XG4gIHdpZHRoOiBcIndcIixcbiAgaGVpZ2h0OiBcImhcIixcbiAgYXNwZWN0UmF0aW86IFwiYXJcIixcbiAgYmFja2dyb3VuZDogXCJiZ1wiLFxuICBib3JkZXI6IFwiYlwiLFxuICBjcm9wOiBcImNcIixcbiAgY3JvcE1vZGU6IFwiY21cIixcbiAgZHByOiBcImRwclwiLFxuICBmb2N1czogXCJmb1wiLFxuICBxdWFsaXR5OiBcInFcIixcbiAgeDogXCJ4XCIsXG4gIHhDZW50ZXI6IFwieGNcIixcbiAgeTogXCJ5XCIsXG4gIHlDZW50ZXI6IFwieWNcIixcbiAgZm9ybWF0OiBcImZcIixcbiAgdmlkZW9Db2RlYzogXCJ2Y1wiLFxuICBhdWRpb0NvZGVjOiBcImFjXCIsXG4gIHJhZGl1czogXCJyXCIsXG4gIHJvdGF0aW9uOiBcInJ0XCIsXG4gIGJsdXI6IFwiYmxcIixcbiAgbmFtZWQ6IFwiblwiLFxuICBkZWZhdWx0SW1hZ2U6IFwiZGlcIixcbiAgZmxpcDogXCJmbFwiLFxuICBvcmlnaW5hbDogXCJvcmlnXCIsXG4gIHN0YXJ0T2Zmc2V0OiBcInNvXCIsXG4gIGVuZE9mZnNldDogXCJlb1wiLFxuICBkdXJhdGlvbjogXCJkdVwiLFxuICBzdHJlYW1pbmdSZXNvbHV0aW9uczogXCJzclwiLFxuICBncmF5c2NhbGU6IFwiZS1ncmF5c2NhbGVcIixcbiAgYWlVcHNjYWxlOiBcImUtdXBzY2FsZVwiLFxuICBhaVJldG91Y2g6IFwiZS1yZXRvdWNoXCIsXG4gIGFpVmFyaWF0aW9uOiBcImUtZ2VudmFyXCIsXG4gIGFpRHJvcFNoYWRvdzogXCJlLWRyb3BzaGFkb3dcIixcbiAgYWlDaGFuZ2VCYWNrZ3JvdW5kOiBcImUtY2hhbmdlYmdcIixcbiAgYWlSZW1vdmVCYWNrZ3JvdW5kOiBcImUtYmdyZW1vdmVcIixcbiAgYWlSZW1vdmVCYWNrZ3JvdW5kRXh0ZXJuYWw6IFwiZS1yZW1vdmVkb3RiZ1wiLFxuICBjb250cmFzdFN0cmV0Y2g6IFwiZS1jb250cmFzdFwiLFxuICBzaGFkb3c6IFwiZS1zaGFkb3dcIixcbiAgc2hhcnBlbjogXCJlLXNoYXJwZW5cIixcbiAgdW5zaGFycE1hc2s6IFwiZS11c21cIixcbiAgZ3JhZGllbnQ6IFwiZS1ncmFkaWVudFwiLFxuICBwcm9ncmVzc2l2ZTogXCJwclwiLFxuICBsb3NzbGVzczogXCJsb1wiLFxuICBjb2xvclByb2ZpbGU6IFwiY3BcIixcbiAgbWV0YWRhdGE6IFwibWRcIixcbiAgb3BhY2l0eTogXCJvXCIsXG4gIHRyaW06IFwidFwiLFxuICB6b29tOiBcInpcIixcbiAgcGFnZTogXCJwZ1wiLFxuICBmb250U2l6ZTogXCJmc1wiLFxuICBmb250RmFtaWx5OiBcImZmXCIsXG4gIGZvbnRDb2xvcjogXCJjb1wiLFxuICBpbm5lckFsaWdubWVudDogXCJpYVwiLFxuICBwYWRkaW5nOiBcInBhXCIsXG4gIGFscGhhOiBcImFsXCIsXG4gIHR5cG9ncmFwaHk6IFwidGdcIixcbiAgbGluZUhlaWdodDogXCJsaFwiLFxuICBmb250T3V0bGluZTogXCJmb2xcIixcbiAgZm9udFNoYWRvdzogXCJmc2hcIixcbiAgcmF3OiBcInJhd1wiXG59O1xuXG5jb25zdCBRVUVSWV9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTiA9IFwicXVlcnlcIjtcbmNvbnN0IENIQUlOX1RSQU5TRk9STV9ERUxJTUlURVIgPSBcIjpcIjtcbmNvbnN0IFRSQU5TRk9STV9ERUxJTUlURVIgPSBcIixcIjtcbmNvbnN0IFRSQU5TRk9STV9LRVlfVkFMVUVfREVMSU1JVEVSID0gXCItXCI7XG52YXIgdHJhbnNmb3JtYXRpb25VdGlscyA9IHtcbiAgYWRkQXNRdWVyeVBhcmFtZXRlcjogb3B0aW9ucyA9PiB7XG4gICAgcmV0dXJuIG9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbiA9PT0gUVVFUllfVFJBTlNGT1JNQVRJT05fUE9TSVRJT047XG4gIH0sXG4gIGdldFRyYW5zZm9ybUtleTogZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZFRyYW5zZm9ybXNbdHJhbnNmb3JtXSB8fCBzdXBwb3J0ZWRUcmFuc2Zvcm1zW3RyYW5zZm9ybS50b0xvd2VyQ2FzZSgpXSB8fCBcIlwiO1xuICB9LFxuICBnZXRDaGFpblRyYW5zZm9ybURlbGltaXRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBDSEFJTl9UUkFOU0ZPUk1fREVMSU1JVEVSO1xuICB9LFxuICBnZXRUcmFuc2Zvcm1EZWxpbWl0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNGT1JNX0RFTElNSVRFUjtcbiAgfSxcbiAgZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNGT1JNX0tFWV9WQUxVRV9ERUxJTUlURVI7XG4gIH1cbn07XG5jb25zdCBzYWZlQnRvYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gYnRvYShzdHIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfVxufTtcblxuY29uc3QgVFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSID0gXCJ0clwiO1xuY29uc3QgU0lNUExFX09WRVJMQVlfUEFUSF9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bYS16QS1aMC05LS5fLyBdKiQnKTtcbmNvbnN0IFNJTVBMRV9PVkVSTEFZX1RFWFRfUkVHRVggPSBuZXcgUmVnRXhwKCdeW2EtekEtWjAtOS0uXyBdKiQnKTtcbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2goc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PSBcIi9cIikge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkaW5nU2xhc2goc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgJiYgc3RyWzBdID09IFwiL1wiKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwYXRoSm9pbihwYXJ0cywgc2VwKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBzZXAgfHwgXCIvXCI7XG4gIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cChzZXBhcmF0b3IgKyBcInsxLH1cIiwgXCJnXCIpO1xuICByZXR1cm4gcGFydHMuam9pbihzZXBhcmF0b3IpLnJlcGxhY2UocmVwbGFjZSwgc2VwYXJhdG9yKTtcbn1cbmNvbnN0IGJ1aWxkU3JjID0gb3B0cyA9PiB7XG4gIG9wdHMudXJsRW5kcG9pbnQgPSBvcHRzLnVybEVuZHBvaW50IHx8IFwiXCI7XG4gIG9wdHMuc3JjID0gb3B0cy5zcmMgfHwgXCJcIjtcbiAgb3B0cy50cmFuc2Zvcm1hdGlvblBvc2l0aW9uID0gb3B0cy50cmFuc2Zvcm1hdGlvblBvc2l0aW9uIHx8IFwicXVlcnlcIjtcbiAgaWYgKCFvcHRzLnNyYykge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IGlzQWJzb2x1dGVVUkwgPSBvcHRzLnNyYy5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBvcHRzLnNyYy5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIik7XG4gIHZhciB1cmxPYmosIGlzU3JjUGFyYW1ldGVyVXNlZEZvclVSTCwgdXJsRW5kcG9pbnRQYXR0ZXJuO1xuICB0cnkge1xuICAgIGlmICghaXNBYnNvbHV0ZVVSTCkge1xuICAgICAgdXJsRW5kcG9pbnRQYXR0ZXJuID0gbmV3IFVSTChvcHRzLnVybEVuZHBvaW50KS5wYXRobmFtZTtcbiAgICAgIHVybE9iaiA9IG5ldyBVUkwocGF0aEpvaW4oW29wdHMudXJsRW5kcG9pbnQucmVwbGFjZSh1cmxFbmRwb2ludFBhdHRlcm4sIFwiXCIpLCBvcHRzLnNyY10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsT2JqID0gbmV3IFVSTChvcHRzLnNyYyk7XG4gICAgICBpc1NyY1BhcmFtZXRlclVzZWRGb3JVUkwgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZm9yICh2YXIgaSBpbiBvcHRzLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuYXBwZW5kKGksIFN0cmluZyhvcHRzLnF1ZXJ5UGFyYW1ldGVyc1tpXSkpO1xuICB9XG4gIHZhciB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGJ1aWxkVHJhbnNmb3JtYXRpb25TdHJpbmcob3B0cy50cmFuc2Zvcm1hdGlvbik7XG4gIGlmICh0cmFuc2Zvcm1hdGlvblN0cmluZyAmJiB0cmFuc2Zvcm1hdGlvblN0cmluZy5sZW5ndGgpIHtcbiAgICBpZiAoIXRyYW5zZm9ybWF0aW9uVXRpbHMuYWRkQXNRdWVyeVBhcmFtZXRlcihvcHRzKSAmJiAhaXNTcmNQYXJhbWV0ZXJVc2VkRm9yVVJMKSB7XG4gICAgICB1cmxPYmoucGF0aG5hbWUgPSBwYXRoSm9pbihbVFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSICsgdHJhbnNmb3JtYXRpb25VdGlscy5nZXRDaGFpblRyYW5zZm9ybURlbGltaXRlcigpICsgdHJhbnNmb3JtYXRpb25TdHJpbmcsIHVybE9iai5wYXRobmFtZV0pO1xuICAgIH1cbiAgfVxuICBpZiAodXJsRW5kcG9pbnRQYXR0ZXJuKSB7XG4gICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aEpvaW4oW3VybEVuZHBvaW50UGF0dGVybiwgdXJsT2JqLnBhdGhuYW1lXSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aEpvaW4oW3VybE9iai5wYXRobmFtZV0pO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1hdGlvblN0cmluZyAmJiB0cmFuc2Zvcm1hdGlvblN0cmluZy5sZW5ndGgpIHtcbiAgICBpZiAodHJhbnNmb3JtYXRpb25VdGlscy5hZGRBc1F1ZXJ5UGFyYW1ldGVyKG9wdHMpIHx8IGlzU3JjUGFyYW1ldGVyVXNlZEZvclVSTCkge1xuICAgICAgaWYgKHVybE9iai5zZWFyY2hQYXJhbXMudG9TdHJpbmcoKSAhPT0gXCJcIikge1xuICAgICAgICByZXR1cm4gYCR7dXJsT2JqLmhyZWZ9JiR7VFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSfT0ke3RyYW5zZm9ybWF0aW9uU3RyaW5nfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7dXJsT2JqLmhyZWZ9PyR7VFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSfT0ke3RyYW5zZm9ybWF0aW9uU3RyaW5nfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmxPYmouaHJlZjtcbn07XG5mdW5jdGlvbiBwcm9jZXNzSW5wdXRQYXRoKHN0ciwgZW5jY29kaW5nKSB7XG4gIHN0ciA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocmVtb3ZlTGVhZGluZ1NsYXNoKHN0cikpO1xuICBpZiAoZW5jY29kaW5nID09PSBcInBsYWluXCIpIHtcbiAgICByZXR1cm4gYGktJHtzdHIucmVwbGFjZSgvXFwvL2csIFwiQEBcIil9YDtcbiAgfVxuICBpZiAoZW5jY29kaW5nID09PSBcImJhc2U2NFwiKSB7XG4gICAgcmV0dXJuIGBpZS0ke2VuY29kZVVSSUNvbXBvbmVudChzYWZlQnRvYShzdHIpKX1gO1xuICB9XG4gIGlmIChTSU1QTEVfT1ZFUkxBWV9QQVRIX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBgaS0ke3N0ci5yZXBsYWNlKC9cXC8vZywgXCJAQFwiKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgaWUtJHtlbmNvZGVVUklDb21wb25lbnQoc2FmZUJ0b2Eoc3RyKSl9YDtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1RleHQoc3RyLCBlbmNjb2RpbmcpIHtcbiAgaWYgKGVuY2NvZGluZyA9PT0gXCJwbGFpblwiKSB7XG4gICAgcmV0dXJuIGBpLSR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0cil9YDtcbiAgfVxuICBpZiAoZW5jY29kaW5nID09PSBcImJhc2U2NFwiKSB7XG4gICAgcmV0dXJuIGBpZS0ke2VuY29kZVVSSUNvbXBvbmVudChzYWZlQnRvYShzdHIpKX1gO1xuICB9XG4gIGlmIChTSU1QTEVfT1ZFUkxBWV9URVhUX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBgaS0ke2VuY29kZVVSSUNvbXBvbmVudChzdHIpfWA7XG4gIH1cbiAgcmV0dXJuIGBpZS0ke2VuY29kZVVSSUNvbXBvbmVudChzYWZlQnRvYShzdHIpKX1gO1xufVxuZnVuY3Rpb24gcHJvY2Vzc092ZXJsYXkob3ZlcmxheSkge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHBvc2l0aW9uID0ge30sXG4gICAgdGltaW5nID0ge30sXG4gICAgdHJhbnNmb3JtYXRpb24gPSBbXVxuICB9ID0gb3ZlcmxheSB8fCB7fTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHRleHRPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgaWYgKCF0ZXh0T3ZlcmxheS50ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY2NvZGluZyA9IHRleHRPdmVybGF5LmVuY29kaW5nIHx8IFwiYXV0b1wiO1xuICAgICAgICBlbnRyaWVzLnB1c2goXCJsLXRleHRcIik7XG4gICAgICAgIGVudHJpZXMucHVzaChwcm9jZXNzVGV4dCh0ZXh0T3ZlcmxheS50ZXh0LCBlbmNjb2RpbmcpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgZW50cmllcy5wdXNoKFwibC1pbWFnZVwiKTtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgaW1hZ2VPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgY29uc3QgZW5jY29kaW5nID0gaW1hZ2VPdmVybGF5LmVuY29kaW5nIHx8IFwiYXV0b1wiO1xuICAgICAgICBpZiAoaW1hZ2VPdmVybGF5LmlucHV0KSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHByb2Nlc3NJbnB1dFBhdGgoaW1hZ2VPdmVybGF5LmlucHV0LCBlbmNjb2RpbmcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgZW50cmllcy5wdXNoKFwibC12aWRlb1wiKTtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgdmlkZW9PdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgY29uc3QgZW5jY29kaW5nID0gdmlkZW9PdmVybGF5LmVuY29kaW5nIHx8IFwiYXV0b1wiO1xuICAgICAgICBpZiAodmlkZW9PdmVybGF5LmlucHV0KSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHByb2Nlc3NJbnB1dFBhdGgodmlkZW9PdmVybGF5LmlucHV0LCBlbmNjb2RpbmcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdWJ0aXRsZVwiOlxuICAgICAgZW50cmllcy5wdXNoKFwibC1zdWJ0aXRsZVwiKTtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qgc3VidGl0bGVPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgY29uc3QgZW5jY29kaW5nID0gc3VidGl0bGVPdmVybGF5LmVuY29kaW5nIHx8IFwiYXV0b1wiO1xuICAgICAgICBpZiAoc3VidGl0bGVPdmVybGF5LmlucHV0KSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHByb2Nlc3NJbnB1dFBhdGgoc3VidGl0bGVPdmVybGF5LmlucHV0LCBlbmNjb2RpbmcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzb2xpZENvbG9yXCI6XG4gICAgICBlbnRyaWVzLnB1c2goXCJsLWltYWdlXCIpO1xuICAgICAgZW50cmllcy5wdXNoKGBpLWlrX2NhbnZhc2ApO1xuICAgICAge1xuICAgICAgICBjb25zdCBzb2xpZENvbG9yT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIGlmIChzb2xpZENvbG9yT3ZlcmxheS5jb2xvcikge1xuICAgICAgICAgIGVudHJpZXMucHVzaChgYmctJHtzb2xpZENvbG9yT3ZlcmxheS5jb2xvcn1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgZm9jdXNcbiAgfSA9IHBvc2l0aW9uO1xuICBpZiAoeCkge1xuICAgIGVudHJpZXMucHVzaChgbHgtJHt4fWApO1xuICB9XG4gIGlmICh5KSB7XG4gICAgZW50cmllcy5wdXNoKGBseS0ke3l9YCk7XG4gIH1cbiAgaWYgKGZvY3VzKSB7XG4gICAgZW50cmllcy5wdXNoKGBsZm8tJHtmb2N1c31gKTtcbiAgfVxuICBjb25zdCB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGR1cmF0aW9uXG4gIH0gPSB0aW1pbmc7XG4gIGlmIChzdGFydCkge1xuICAgIGVudHJpZXMucHVzaChgbHNvLSR7c3RhcnR9YCk7XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIGVudHJpZXMucHVzaChgbGVvLSR7ZW5kfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbikge1xuICAgIGVudHJpZXMucHVzaChgbGR1LSR7ZHVyYXRpb259YCk7XG4gIH1cbiAgY29uc3QgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBidWlsZFRyYW5zZm9ybWF0aW9uU3RyaW5nKHRyYW5zZm9ybWF0aW9uKTtcbiAgaWYgKHRyYW5zZm9ybWF0aW9uU3RyaW5nICYmIHRyYW5zZm9ybWF0aW9uU3RyaW5nLnRyaW0oKSAhPT0gXCJcIikgZW50cmllcy5wdXNoKHRyYW5zZm9ybWF0aW9uU3RyaW5nKTtcbiAgZW50cmllcy5wdXNoKFwibC1lbmRcIik7XG4gIHJldHVybiBlbnRyaWVzLmpvaW4odHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1EZWxpbWl0ZXIoKSk7XG59XG5jb25zdCBidWlsZFRyYW5zZm9ybWF0aW9uU3RyaW5nID0gZnVuY3Rpb24gKHRyYW5zZm9ybWF0aW9uKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1hdGlvbikpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB2YXIgcGFyc2VkVHJhbnNmb3JtcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybWF0aW9uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYXJzZWRUcmFuc2Zvcm1TdGVwID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRyYW5zZm9ybWF0aW9uW2ldKSB7XG4gICAgICBsZXQgdmFsdWUgPSB0cmFuc2Zvcm1hdGlvbltpXVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcIm92ZXJsYXlcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHJhd1N0cmluZyA9IHByb2Nlc3NPdmVybGF5KHZhbHVlKTtcbiAgICAgICAgaWYgKHJhd1N0cmluZyAmJiByYXdTdHJpbmcudHJpbSgpICE9PSBcIlwiKSB7XG4gICAgICAgICAgcGFyc2VkVHJhbnNmb3JtU3RlcC5wdXNoKHJhd1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNmb3JtS2V5ID0gdHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1LZXkoa2V5KTtcbiAgICAgIGlmICghdHJhbnNmb3JtS2V5KSB7XG4gICAgICAgIHRyYW5zZm9ybUtleSA9IGtleTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1LZXkgPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoW1wiZS1ncmF5c2NhbGVcIiwgXCJlLWNvbnRyYXN0XCIsIFwiZS1yZW1vdmVkb3RiZ1wiLCBcImUtYmdyZW1vdmVcIiwgXCJlLXVwc2NhbGVcIiwgXCJlLXJldG91Y2hcIiwgXCJlLWdlbnZhclwiXS5pbmNsdWRlcyh0cmFuc2Zvcm1LZXkpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gXCItXCIgfHwgdmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgcGFyc2VkVHJhbnNmb3JtU3RlcC5wdXNoKHRyYW5zZm9ybUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoW1wiZS1zaGFycGVuXCIsIFwiZS1zaGFkb3dcIiwgXCJlLWdyYWRpZW50XCIsIFwiZS11c21cIiwgXCJlLWRyb3BzaGFkb3dcIl0uaW5jbHVkZXModHJhbnNmb3JtS2V5KSAmJiAodmFsdWUudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCIgfHwgdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IFwidHJ1ZVwiKSkge1xuICAgICAgICBwYXJzZWRUcmFuc2Zvcm1TdGVwLnB1c2godHJhbnNmb3JtS2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJhd1wiKSB7XG4gICAgICAgIHBhcnNlZFRyYW5zZm9ybVN0ZXAucHVzaCh0cmFuc2Zvcm1hdGlvbltpXVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1LZXkgPT09IFwiZGlcIikge1xuICAgICAgICAgIHZhbHVlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChyZW1vdmVMZWFkaW5nU2xhc2godmFsdWUgfHwgXCJcIikpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvL2csIFwiQEBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybUtleSA9PT0gXCJzclwiICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKFwiX1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtS2V5ID09PSBcInRcIiAmJiB2YWx1ZS50b1N0cmluZygpLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgIHZhbHVlID0gXCJ0cnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkVHJhbnNmb3JtU3RlcC5wdXNoKFt0cmFuc2Zvcm1LZXksIHZhbHVlXS5qb2luKHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXIoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkVHJhbnNmb3JtU3RlcC5sZW5ndGgpIHtcbiAgICAgIHBhcnNlZFRyYW5zZm9ybXMucHVzaChwYXJzZWRUcmFuc2Zvcm1TdGVwLmpvaW4odHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1EZWxpbWl0ZXIoKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkVHJhbnNmb3Jtcy5qb2luKHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0Q2hhaW5UcmFuc2Zvcm1EZWxpbWl0ZXIoKSk7XG59O1xuXG5jb25zdCBERUZBVUxUX0RFVklDRV9CUkVBS1BPSU5UUyA9IFs2NDAsIDc1MCwgODI4LCAxMDgwLCAxMjAwLCAxOTIwLCAyMDQ4LCAzODQwXTtcbmNvbnN0IERFRkFVTFRfSU1BR0VfQlJFQUtQT0lOVFMgPSBbMTYsIDMyLCA0OCwgNjQsIDk2LCAxMjgsIDI1NiwgMzg0XTtcbmZ1bmN0aW9uIGdldFJlc3BvbnNpdmVJbWFnZUF0dHJpYnV0ZXMob3B0cykge1xuICBjb25zdCB7XG4gICAgc3JjLFxuICAgIHVybEVuZHBvaW50LFxuICAgIHRyYW5zZm9ybWF0aW9uID0gW10sXG4gICAgcXVlcnlQYXJhbWV0ZXJzLFxuICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgc2l6ZXMsXG4gICAgd2lkdGgsXG4gICAgZGV2aWNlQnJlYWtwb2ludHMgPSBERUZBVUxUX0RFVklDRV9CUkVBS1BPSU5UUyxcbiAgICBpbWFnZUJyZWFrcG9pbnRzID0gREVGQVVMVF9JTUFHRV9CUkVBS1BPSU5UU1xuICB9ID0gb3B0cztcbiAgY29uc3Qgc29ydGVkRGV2aWNlQnJlYWtwb2ludHMgPSBbLi4uZGV2aWNlQnJlYWtwb2ludHNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgY29uc3Qgc29ydGVkSW1hZ2VCcmVha3BvaW50cyA9IFsuLi5pbWFnZUJyZWFrcG9pbnRzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IGFsbEJyZWFrcG9pbnRzID0gWy4uLnNvcnRlZEltYWdlQnJlYWtwb2ludHMsIC4uLnNvcnRlZERldmljZUJyZWFrcG9pbnRzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IHtcbiAgICBjYW5kaWRhdGVzLFxuICAgIGRlc2NyaXB0b3JLaW5kXG4gIH0gPSBjb21wdXRlQ2FuZGlkYXRlV2lkdGhzKHtcbiAgICBhbGxCcmVha3BvaW50cyxcbiAgICBkZXZpY2VCcmVha3BvaW50czogc29ydGVkRGV2aWNlQnJlYWtwb2ludHMsXG4gICAgZXhwbGljaXRXaWR0aDogd2lkdGgsXG4gICAgc2l6ZXNBdHRyOiBzaXplc1xuICB9KTtcbiAgY29uc3QgYnVpbGRVUkwgPSB3ID0+IGJ1aWxkU3JjKHtcbiAgICBzcmMsXG4gICAgdXJsRW5kcG9pbnQsXG4gICAgcXVlcnlQYXJhbWV0ZXJzLFxuICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgdHJhbnNmb3JtYXRpb246IFsuLi50cmFuc2Zvcm1hdGlvbiwge1xuICAgICAgd2lkdGg6IHcsXG4gICAgICBjcm9wOiAnYXRfbWF4J1xuICAgIH1cbiAgICBdXG4gIH0pO1xuICBjb25zdCBzcmNTZXQgPSBjYW5kaWRhdGVzLm1hcCgodywgaSkgPT4gYCR7YnVpbGRVUkwodyl9ICR7ZGVzY3JpcHRvcktpbmQgPT09ICd3JyA/IHcgOiBpICsgMX0ke2Rlc2NyaXB0b3JLaW5kfWApLmpvaW4oJywgJykgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBmaW5hbFNpemVzID0gc2l6ZXMgPz8gKGRlc2NyaXB0b3JLaW5kID09PSAndycgPyAnMTAwdncnIDogdW5kZWZpbmVkKTtcbiAgcmV0dXJuIHtcbiAgICBzcmM6IGJ1aWxkVVJMKGNhbmRpZGF0ZXNbY2FuZGlkYXRlcy5sZW5ndGggLSAxXSksXG4gICAgc3JjU2V0LFxuICAgIC4uLihmaW5hbFNpemVzID8ge1xuICAgICAgc2l6ZXM6IGZpbmFsU2l6ZXNcbiAgICB9IDoge30pLFxuICAgIC4uLih3aWR0aCAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgd2lkdGhcbiAgICB9IDoge30pXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuZGlkYXRlV2lkdGhzKHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgYWxsQnJlYWtwb2ludHMsXG4gICAgZGV2aWNlQnJlYWtwb2ludHMsXG4gICAgZXhwbGljaXRXaWR0aCxcbiAgICBzaXplc0F0dHJcbiAgfSA9IHBhcmFtcztcbiAgaWYgKHNpemVzQXR0cikge1xuICAgIGNvbnN0IHZ3VG9rZW5zID0gc2l6ZXNBdHRyLm1hdGNoKC8oXnxcXHMpKDE/XFxkezEsMn0pdncvZykgfHwgW107XG4gICAgY29uc3QgdndQZXJjZW50cyA9IHZ3VG9rZW5zLm1hcCh0ID0+IHBhcnNlSW50KHQsIDEwKSk7XG4gICAgaWYgKHZ3UGVyY2VudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4udndQZXJjZW50cykgLyAxMDA7XG4gICAgICBjb25zdCBtaW5SZXF1aXJlZFB4ID0gZGV2aWNlQnJlYWtwb2ludHNbMF0gKiBzbWFsbGVzdFJhdGlvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuZGlkYXRlczogYWxsQnJlYWtwb2ludHMuZmlsdGVyKHcgPT4gdyA+PSBtaW5SZXF1aXJlZFB4KSxcbiAgICAgICAgZGVzY3JpcHRvcktpbmQ6ICd3J1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmRpZGF0ZXM6IGFsbEJyZWFrcG9pbnRzLFxuICAgICAgZGVzY3JpcHRvcktpbmQ6ICd3J1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBleHBsaWNpdFdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5kaWRhdGVzOiBkZXZpY2VCcmVha3BvaW50cyxcbiAgICAgIGRlc2NyaXB0b3JLaW5kOiAndydcbiAgICB9O1xuICB9XG4gIGNvbnN0IG5lYXJlc3QgPSB0ID0+IGFsbEJyZWFrcG9pbnRzLmZpbmQobiA9PiBuID49IHQpIHx8IGFsbEJyZWFrcG9pbnRzW2FsbEJyZWFrcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCB1bmlxdWUgPSBBcnJheS5mcm9tKG5ldyBTZXQoW25lYXJlc3QoZXhwbGljaXRXaWR0aCksIG5lYXJlc3QoZXhwbGljaXRXaWR0aCAqIDIpXSkpO1xuICByZXR1cm4ge1xuICAgIGNhbmRpZGF0ZXM6IHVuaXF1ZSxcbiAgICBkZXNjcmlwdG9yS2luZDogJ3gnXG4gIH07XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY29uc3QgSW1hZ2VLaXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoZSBgSW1hZ2VLaXRQcm92aWRlcmAgY29tcG9uZW50IHRvIHNldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBuZXN0ZWQgSW1hZ2UgYW5kIFZpZGVvIGNvbXBvbmVudHMgcHJvdmlkZWQgYnkgdGhlIFNESy5cbiAqXG4gKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcHM6XG4gKiAtIGB1cmxFbmRwb2ludGA6IFRoZSBVUkwgZW5kcG9pbnQgZm9yIHlvdXIgSW1hZ2VLaXQgYWNjb3VudC4gWW91IGNhbiBnZXQgdGhpcyBmcm9tIHRoZSBbSW1hZ2VLaXQgZGFzaGJvYXJkXShodHRwczovL2ltYWdla2l0LmlvL2Rhc2hib2FyZC91cmwtZW5kcG9pbnRzKS5cbiAqIC0gYHRyYW5zZm9ybWF0aW9uUG9zaXRpb25gOiBUaGUgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uIHN0cmluZyBpbiB0aGUgVVJMLiBJdCBjYW4gYmUgZWl0aGVyIGBwYXRoYCBvciBgcXVlcnlgLiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gYHF1ZXJ5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgeyBJbWFnZUtpdFByb3ZpZGVyLCBJbWFnZSB9IGZyb20gXCJAaW1hZ2VraXQvbmV4dFwiO1xuICogPEltYWdlS2l0UHJvdmlkZXIgdXJsRW5kcG9pbnQ9XCJodHRwczovL2lrLmltYWdla2l0LmlvL3lvdXJfaW1hZ2VraXRfaWRcIj5cbiAqICAgPEltYWdlIHNyYz1cIi9kZWZhdWx0LWltYWdlLmpwZ1wiIC8+XG4gKiA8L0ltYWdlS2l0UHJvdmlkZXI+XG4gKiBgYGBcbiAqL1xuY29uc3QgSW1hZ2VLaXRQcm92aWRlciA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIHVybEVuZHBvaW50LFxuICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb25cbiAgfSA9IHByb3BzO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZUtpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgdXJsRW5kcG9pbnQsXG4gICAgICB0cmFuc2Zvcm1hdGlvblBvc2l0aW9uXG4gICAgfVxuICB9LCBwcm9wcy5jaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFRoZSBJbWFnZSBjb21wb25lbnQgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgTmV4dC5qcyBJbWFnZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIGFsbCB0aGUgZmVhdHVyZXMgb2YgdGhlIE5leHQuanMgSW1hZ2UgY29tcG9uZW50LCBhbG9uZyB3aXRoIGFkZGl0aW9uYWwgZmVhdHVyZXMgcHJvdmlkZWQgYnkgSW1hZ2VLaXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgSW1hZ2UgfSBmcm9tIFwiQGltYWdla2l0L25leHRcIjtcbiAqIDxJbWFnZVxuICogIHVybEVuZHBvaW50PVwiaHR0cHM6Ly9pay5pbWFnZWtpdC5pby95b3VyX2ltYWdla2l0X2lkXCIgLy8gWW91IGNhbiBhbHNvIHNldCB0aGlzIGluIGEgcGFyZW50IEltYWdlS2l0UHJvdmlkZXIgY29tcG9uZW50XG4gKiAgc3JjPVwiL2RlZmF1bHQtaW1hZ2UuanBnXCIgLy8gVGhlIHBhdGggdG8gdGhlIGltYWdlIGluIHlvdXIgSW1hZ2VLaXQgYWNjb3VudFxuICogIGFsdD1cIkRlZmF1bHQgSW1hZ2VcIlxuICogIHdpZHRoPXs1MDB9XG4gKiAgaGVpZ2h0PXs1MDB9XG4gKiAgdHJhbnNmb3JtYXRpb249e1t7IHdpZHRoOiA1MDAsIGhlaWdodDogNTAwIH1dfSAvLyBBZGQgSW1hZ2VLaXQgdHJhbnNmb3JtYXRpb25zXG4gKiAvPlxuICogYGBgXG4gKi9cbmNvbnN0IEltYWdlID0gcHJvcHMgPT4ge1xuICBpZiAocHJvcHMubG9hZGVyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKCdsb2FkZXIgcHJvcCBpcyBpZ25vcmVkIGJ5IEltYWdlS2l0IEltYWdlIGNvbXBvbmVudC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udGV4dFZhbHVlcyA9IHVzZUNvbnRleHQoSW1hZ2VLaXRDb250ZXh0KTtcbiAgLy8gSXRzIGltcG9ydGFudCB0byBleHRyYWN0IHRoZSBJbWFnZUtpdCBzcGVjaWZpYyBwcm9wcyBmcm9tIHRoZSBwcm9wcywgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSByZXN0IG9mIHRoZSBwcm9wcyBhcyBpcyBpbiB0aGUgTmV4dEltYWdlIGNvbXBvbmVudFxuICBjb25zdCBfYSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dFZhbHVlcyksIHByb3BzIC8vIE92ZXJyaWRlIHdpdGggcHJvcHNcbiAgICApLFxuICAgIHtcbiAgICAgIHRyYW5zZm9ybWF0aW9uID0gW10sXG4gICAgICB1bm9wdGltaXplZCA9IGZhbHNlLFxuICAgICAgcXVhbGl0eSxcbiAgICAgIHNyYyA9IFwiXCIsXG4gICAgICBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICB1cmxFbmRwb2ludCxcbiAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgICByZXNwb25zaXZlID0gdHJ1ZSxcbiAgICAgIGxvYWRlclxuICAgIH0gPSBfYSxcbiAgICBub25JS1BhcmFtcyA9IF9fcmVzdChfYSwgW1widHJhbnNmb3JtYXRpb25cIiwgXCJ1bm9wdGltaXplZFwiLCBcInF1YWxpdHlcIiwgXCJzcmNcIiwgXCJxdWVyeVBhcmFtZXRlcnNcIiwgXCJ1cmxFbmRwb2ludFwiLCBcInRyYW5zZm9ybWF0aW9uUG9zaXRpb25cIiwgXCJyZXNwb25zaXZlXCIsIFwibG9hZGVyXCJdKTtcbiAgaWYgKCF1cmxFbmRwb2ludCB8fCB1cmxFbmRwb2ludC50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwidXJsRW5kcG9pbnQgaXMgbmVpdGhlciBwcm92aWRlZCBpbiB0aGlzIGNvbXBvbmVudCBub3IgaW4gdGhlIEltYWdlS2l0Q29udGV4dC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGlzQWJzb2x1dGVVUkwgPSBzcmMuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgc3JjLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKTtcbiAgLy8gRG8gbm90IG11dGF0ZSBvcmlnaW5hbCB0cmFuc2Zvcm1hdGlvbiBhcnJheSBmcm9tIHRoZSBwcm9wc1xuICBjb25zdCBmaW5hbFRyYW5zZm9ybWF0aW9uID0gWy4uLnRyYW5zZm9ybWF0aW9uXTtcbiAgbGV0IHByb3BzVHJhbnNmb3JtYXRpb24gPSB7fTtcbiAgaWYgKHF1YWxpdHkpIHtcbiAgICBjb25zdCBwYXJzZWRRdWFsaXR5ID0gTnVtYmVyKHF1YWxpdHkpO1xuICAgIGlmICghaXNOYU4ocGFyc2VkUXVhbGl0eSkpIHtcbiAgICAgIHByb3BzVHJhbnNmb3JtYXRpb24ucXVhbGl0eSA9IHBhcnNlZFF1YWxpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBxdWFsaXR5IHZhbHVlLCBza2lwcGluZyB0cmFuc2Zvcm1hdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIG9yaWdpbmFsIGZpbGUgd2l0aG91dCBhbnkgdHJhbnNmb3JtYXRpb24gb3Igb3B0aW1pemF0aW9uIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZiBOZXh0SW1hZ2VcbiAgLy8gQWx3YXlzIGtlZXAgc3JjIGluIHRoZSBlbmRcbiAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTmV4dEltYWdlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIHVub3B0aW1pemVkOiB0cnVlXG4gICAgfSwgbm9uSUtQYXJhbXMsIHtcbiAgICAgIHNyYzogYnVpbGRTcmMoe1xuICAgICAgICB1cmxFbmRwb2ludCxcbiAgICAgICAgc3JjLFxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uOiBbe1xuICAgICAgICAgIFwicmF3XCI6IFwib3JpZy10cnVlXCJcbiAgICAgICAgfV1cbiAgICAgIH0pXG4gICAgfSkpO1xuICB9XG4gIC8vIFVzZXIgZGlzYWJsZWQgcmVzcG9uc2l2ZSBpbWFnZXNcbiAgaWYgKCFyZXNwb25zaXZlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTmV4dEltYWdlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIHVub3B0aW1pemVkOiB0cnVlXG4gICAgfSwgbm9uSUtQYXJhbXMsIHtcbiAgICAgIHNyYzogYnVpbGRTcmMoe1xuICAgICAgICB1cmxFbmRwb2ludCxcbiAgICAgICAgc3JjLFxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgICAgIC8vIGtlZXAgb25seSB1c2Vy4oCRc3VwcGxpZWQgdHJhbnNmb3JtYXRpb25zO25vIHdpZHRoLCBubyBjcm9wXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uOiBbLi4uZmluYWxUcmFuc2Zvcm1hdGlvbiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUcmFuc2Zvcm1hdGlvbildXG4gICAgICB9KVxuICAgIH0pKTtcbiAgfVxuICAvLyBEb24ndCBwYXNzIHRyYW5zZm9ybWF0aW9uIGp1c3QgeWV0IGFzIGxvYWRlciB3aWxsIHRha2UgY2FyZSBvZiBpdCBhbG9uZyB3aXRoIHdpZHRoIGZvciBzcmNzZXQgZ2VuZXJhdGlvbiBhcyBwZXIgTmV4dC5qcyBsb2dpYy5cbiAgY29uc3QgZmluYWxTcmNXaXRob3V0VHJhbnNmb3JtYXRpb24gPSBidWlsZFNyYyh7XG4gICAgdXJsRW5kcG9pbnQsXG4gICAgcXVlcnlQYXJhbWV0ZXJzLFxuICAgIHNyY1xuICB9KTtcbiAgcmV0dXJuIChcbiAgICAvLyBBbHdheXMga2VlcCBzcmMgaW4gdGhlIGVuZFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTmV4dEltYWdlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxvYWRlcjogKHtcbiAgICAgICAgc3JjLFxuICAgICAgICB3aWR0aFxuICAgICAgfSkgPT4ge1xuICAgICAgICAvLyBTaW5jZSBgc3JjYCBpbnNpZGUgbG9hZGVyIGlzIGFsd2F5cyBhYnNvbHV0ZSwgYGJ1aWxkU3JjYCB3b24ndCByZXNwZWN0IHRoZSBgcGF0aGAgdHJhbnNmb3JtYXRpb24gcG9zaXRpb24uXG4gICAgICAgIC8vIFRvIGZpeCB0aGlzLCBpZiB0aGUgb3JpZ2luYWwgc3JjIHByb3AgaXNuJ3QgYW4gYWJzb2x1dGUgVVJMLCByZW1vdmUgYHVybEVuZHBvaW50YCBmcm9tIHRoaXMgYHNyY2BcbiAgICAgICAgLy8gYmVmb3JlIGNhbGxpbmcgYGJ1aWxkU3JjYC4gT3RoZXJ3aXNlLCBsZWF2ZSBpdCBhcyBpcy5cbiAgICAgICAgY29uc3Qgc3JjV2l0aG91dFVybEVuZHBvaW50ID0gIWlzQWJzb2x1dGVVUkwgPyBzcmMucmVwbGFjZSh1cmxFbmRwb2ludCwgXCJcIikgOiBzcmM7XG4gICAgICAgIGNvbnN0IGZpbmFsU3JjID0gYnVpbGRTcmMoe1xuICAgICAgICAgIHVybEVuZHBvaW50LFxuICAgICAgICAgIHNyYzogc3JjV2l0aG91dFVybEVuZHBvaW50LFxuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24sXG4gICAgICAgICAgdHJhbnNmb3JtYXRpb246IFsuLi5maW5hbFRyYW5zZm9ybWF0aW9uLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzVHJhbnNmb3JtYXRpb24pLCB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGNyb3A6IFwiYXRfbWF4XCJcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFNyYztcbiAgICAgIH1cbiAgICB9LCBub25JS1BhcmFtcywge1xuICAgICAgc3JjOiBmaW5hbFNyY1dpdGhvdXRUcmFuc2Zvcm1hdGlvblxuICAgIH0pKVxuICApO1xufTtcblxuLyoqXG4gKiBUaGUgVmlkZW8gY29tcG9uZW50IGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIEhUTUwgdmlkZW8gZWxlbWVudC4gSXQgc3VwcG9ydHMgYWxsIHRoZSBmZWF0dXJlcyBvZiB0aGUgSFRNTCB2aWRlbyBlbGVtZW50LCBhbG9uZyB3aXRoIGFkZGl0aW9uYWwgZmVhdHVyZXMgcHJvdmlkZWQgYnkgSW1hZ2VLaXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgVmlkZW8gfSBmcm9tIFwiQGltYWdla2l0L25leHRcIjtcbiAqIDxWaWRlb1xuICogIHVybEVuZHBvaW50PVwiaHR0cHM6Ly9pay5pbWFnZWtpdC5pby95b3VyX2ltYWdla2l0X2lkXCIgLy8gWW91IGNhbiBhbHNvIHNldCB0aGlzIGluIGEgcGFyZW50IEltYWdlS2l0UHJvdmlkZXIgY29tcG9uZW50XG4gKiAgc3JjPVwiL2RlZmF1bHQtdmlkZW8ubXA0XCIgLy8gVGhlIHBhdGggdG8gdGhlIHZpZGVvIGluIHlvdXIgSW1hZ2VLaXQgYWNjb3VudFxuICogIGNvbnRyb2xzXG4gKiAgd2lkdGg9ezUwMH1cbiAqICBoZWlnaHQ9ezUwMH1cbiAqICB0cmFuc2Zvcm1hdGlvbj17W3sgd2lkdGg6IDUwMCwgaGVpZ2h0OiA1MDAgfV19IC8vIEFkZCBJbWFnZUtpdCB0cmFuc2Zvcm1hdGlvbnNcbiAqIC8+XG4gKiBgYGBcbiAqL1xuY29uc3QgVmlkZW8gPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZXMgPSB1c2VDb250ZXh0KEltYWdlS2l0Q29udGV4dCk7XG4gIC8vIEl0cyBpbXBvcnRhbnQgdG8gZXh0cmFjdCB0aGUgSW1hZ2VLaXQgc3BlY2lmaWMgcHJvcHMgZnJvbSB0aGUgcHJvcHMsIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGUgcmVzdCBvZiB0aGUgcHJvcHMgYXMgaXMgaW4gdGhlIHZpZGVvIGVsZW1lbnRcbiAgY29uc3QgX2EgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHRWYWx1ZXMpLCBwcm9wcyAvLyBPdmVycmlkZSB3aXRoIHByb3BzXG4gICAgKSxcbiAgICB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbiA9IFtdLFxuICAgICAgc3JjID0gXCJcIixcbiAgICAgIHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgIHVybEVuZHBvaW50LFxuICAgICAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvblxuICAgIH0gPSBfYSxcbiAgICBub25JS1BhcmFtcyA9IF9fcmVzdChfYSwgW1widHJhbnNmb3JtYXRpb25cIiwgXCJzcmNcIiwgXCJxdWVyeVBhcmFtZXRlcnNcIiwgXCJ1cmxFbmRwb2ludFwiLCBcInRyYW5zZm9ybWF0aW9uUG9zaXRpb25cIl0pO1xuICBpZiAoIXVybEVuZHBvaW50IHx8IHVybEVuZHBvaW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1cmxFbmRwb2ludCBpcyBuZWl0aGVyIHByb3ZpZGVkIGluIHRoaXMgY29tcG9uZW50IG5vciBpbiB0aGUgSW1hZ2VLaXRDb250ZXh0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZmluYWxTcmMgPSBidWlsZFNyYyh7XG4gICAgdXJsRW5kcG9pbnQsXG4gICAgc3JjLFxuICAgIHRyYW5zZm9ybWF0aW9uOiBbLi4udHJhbnNmb3JtYXRpb25dLFxuICAgIC8vIERvIG5vdCBtdXRhdGUgb3JpZ2luYWwgdHJhbnNmb3JtYXRpb24gYXJyYXkgZnJvbSB0aGUgcHJvcHNcbiAgICBxdWVyeVBhcmFtZXRlcnMsXG4gICAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvblxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCBPYmplY3QuYXNzaWduKHt9LCBub25JS1BhcmFtcywge1xuICAgIHNyYzogZmluYWxTcmNcbiAgfSkpO1xufTtcblxuZXhwb3J0IHsgSW1hZ2UsIEltYWdlS2l0QWJvcnRFcnJvciwgSW1hZ2VLaXRDb250ZXh0LCBJbWFnZUtpdEludmFsaWRSZXF1ZXN0RXJyb3IsIEltYWdlS2l0UHJvdmlkZXIsIEltYWdlS2l0U2VydmVyRXJyb3IsIEltYWdlS2l0VXBsb2FkTmV0d29ya0Vycm9yLCBWaWRlbywgYnVpbGRTcmMsIGJ1aWxkVHJhbnNmb3JtYXRpb25TdHJpbmcsIGdldFJlc3BvbnNpdmVJbWFnZUF0dHJpYnV0ZXMsIHVwbG9hZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkltYWdlIiwiSW1hZ2VLaXRBYm9ydEVycm9yIiwiSW1hZ2VLaXRDb250ZXh0IiwiSW1hZ2VLaXRJbnZhbGlkUmVxdWVzdEVycm9yIiwiSW1hZ2VLaXRQcm92aWRlciIsIkltYWdlS2l0U2VydmVyRXJyb3IiLCJJbWFnZUtpdFVwbG9hZE5ldHdvcmtFcnJvciIsIlZpZGVvIiwiYnVpbGRTcmMiLCJidWlsZFRyYW5zZm9ybWF0aW9uU3RyaW5nIiwiZ2V0UmVzcG9uc2l2ZUltYWdlQXR0cmlidXRlcyIsInVwbG9hZCIsImVycm9yTWVzc2FnZXMiLCJNSVNTSU5HX1VQTE9BRF9GSUxFX1BBUkFNRVRFUiIsIm1lc3NhZ2UiLCJNSVNTSU5HX1VQTE9BRF9GSUxFTkFNRV9QQVJBTUVURVIiLCJNSVNTSU5HX1BVQkxJQ19LRVkiLCJVUExPQURfRU5EUE9JTlRfTkVUV09SS19FUlJPUiIsIk1JU1NJTkdfU0lHTkFUVVJFIiwiTUlTU0lOR19UT0tFTiIsIk1JU1NJTkdfRVhQSVJFIiwiSU5WQUxJRF9UUkFOU0ZPUk1BVElPTiIsIklOVkFMSURfUFJFX1RSQU5TRk9STUFUSU9OIiwiSU5WQUxJRF9QT1NUX1RSQU5TRk9STUFUSU9OIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlc3BvbnNlTWV0YWRhdGEiLCIkUmVzcG9uc2VNZXRhZGF0YSIsIm5hbWUiLCJyZWFzb24iLCJ1cGxvYWRPcHRpb25zIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc29sdmUiLCJ4aHIiLCJ1c2VyUHJvdmlkZWRYSFIiLCJYTUxIdHRwUmVxdWVzdCIsImZpbGUiLCJmaWxlTmFtZSIsInB1YmxpY0tleSIsImxlbmd0aCIsInRva2VuIiwic2lnbmF0dXJlIiwiZXhwaXJlIiwidHJhbnNmb3JtYXRpb24iLCJPYmplY3QiLCJrZXlzIiwiaW5jbHVkZXMiLCJwcmUiLCJBcnJheSIsImlzQXJyYXkiLCJwb3N0IiwidHlwZSIsInByb3RvY29sIiwidmFsdWUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwia2V5Iiwic2V0IiwiU3RyaW5nIiwidGFncyIsImpvaW4iLCJyZXNwb25zZUZpZWxkcyIsImV4dGVuc2lvbnMiLCJKU09OIiwic3RyaW5naWZ5IiwiY3VzdG9tTWV0YWRhdGEiLCJjaGVja3MiLCJ1bmRlZmluZWQiLCJvblByb2dyZXNzIiwib25wcm9ncmVzcyIsImV2ZW50Iiwib25BYm9ydEhhbmRsZXIiLCJfdXBsb2FkT3B0aW9ucyRhYm9ydFMiLCJhYm9ydCIsImFib3J0U2lnbmFsIiwiYWJvcnRlZCIsIl91cGxvYWRPcHRpb25zJGFib3J0UzIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9wZW4iLCJvbmVycm9yIiwiZSIsIm9ubG9hZCIsInN0YXR1cyIsImJvZHkiLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsInVwbG9hZFJlc3BvbnNlIiwiYWRkUmVzcG9uc2VIZWFkZXJzQW5kQm9keSIsImV4IiwiZ2V0UmVzcG9uc2VNZXRhZGF0YSIsInNlbmQiLCJyZXNwb25zZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiaGVhZGVycyIsImdldFJlc3BvbnNlSGVhZGVyTWFwIiwic3RhdHVzQ29kZSIsInJlcXVlc3RJZCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInRyaW0iLCJzcGxpdCIsIm1hcCIsImZvckVhY2giLCJrZXlWYWx1ZSIsInRvTG93ZXJDYXNlIiwic3VwcG9ydGVkVHJhbnNmb3JtcyIsIndpZHRoIiwiaGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwiY3JvcCIsImNyb3BNb2RlIiwiZHByIiwiZm9jdXMiLCJxdWFsaXR5IiwieCIsInhDZW50ZXIiLCJ5IiwieUNlbnRlciIsImZvcm1hdCIsInZpZGVvQ29kZWMiLCJhdWRpb0NvZGVjIiwicmFkaXVzIiwicm90YXRpb24iLCJibHVyIiwibmFtZWQiLCJkZWZhdWx0SW1hZ2UiLCJmbGlwIiwib3JpZ2luYWwiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImR1cmF0aW9uIiwic3RyZWFtaW5nUmVzb2x1dGlvbnMiLCJncmF5c2NhbGUiLCJhaVVwc2NhbGUiLCJhaVJldG91Y2giLCJhaVZhcmlhdGlvbiIsImFpRHJvcFNoYWRvdyIsImFpQ2hhbmdlQmFja2dyb3VuZCIsImFpUmVtb3ZlQmFja2dyb3VuZCIsImFpUmVtb3ZlQmFja2dyb3VuZEV4dGVybmFsIiwiY29udHJhc3RTdHJldGNoIiwic2hhZG93Iiwic2hhcnBlbiIsInVuc2hhcnBNYXNrIiwiZ3JhZGllbnQiLCJwcm9ncmVzc2l2ZSIsImxvc3NsZXNzIiwiY29sb3JQcm9maWxlIiwibWV0YWRhdGEiLCJvcGFjaXR5Iiwiem9vbSIsInBhZ2UiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJmb250Q29sb3IiLCJpbm5lckFsaWdubWVudCIsInBhZGRpbmciLCJhbHBoYSIsInR5cG9ncmFwaHkiLCJsaW5lSGVpZ2h0IiwiZm9udE91dGxpbmUiLCJmb250U2hhZG93IiwicmF3IiwiUVVFUllfVFJBTlNGT1JNQVRJT05fUE9TSVRJT04iLCJDSEFJTl9UUkFOU0ZPUk1fREVMSU1JVEVSIiwiVFJBTlNGT1JNX0RFTElNSVRFUiIsIlRSQU5TRk9STV9LRVlfVkFMVUVfREVMSU1JVEVSIiwidHJhbnNmb3JtYXRpb25VdGlscyIsImFkZEFzUXVlcnlQYXJhbWV0ZXIiLCJvcHRpb25zIiwidHJhbnNmb3JtYXRpb25Qb3NpdGlvbiIsImdldFRyYW5zZm9ybUtleSIsInRyYW5zZm9ybSIsImdldENoYWluVHJhbnNmb3JtRGVsaW1pdGVyIiwiZ2V0VHJhbnNmb3JtRGVsaW1pdGVyIiwiZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXIiLCJzYWZlQnRvYSIsInN0ciIsImJ0b2EiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJUUkFOU0ZPUk1BVElPTl9QQVJBTUVURVIiLCJTSU1QTEVfT1ZFUkxBWV9QQVRIX1JFR0VYIiwiUmVnRXhwIiwiU0lNUExFX09WRVJMQVlfVEVYVF9SRUdFWCIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJzdWJzdHJpbmciLCJyZW1vdmVMZWFkaW5nU2xhc2giLCJzbGljZSIsInBhdGhKb2luIiwicGFydHMiLCJzZXAiLCJzZXBhcmF0b3IiLCJyZXBsYWNlIiwib3B0cyIsInVybEVuZHBvaW50Iiwic3JjIiwiaXNBYnNvbHV0ZVVSTCIsInN0YXJ0c1dpdGgiLCJ1cmxPYmoiLCJpc1NyY1BhcmFtZXRlclVzZWRGb3JVUkwiLCJ1cmxFbmRwb2ludFBhdHRlcm4iLCJVUkwiLCJwYXRobmFtZSIsImNvbnNvbGUiLCJlcnJvciIsImkiLCJxdWVyeVBhcmFtZXRlcnMiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJ0cmFuc2Zvcm1hdGlvblN0cmluZyIsImhyZWYiLCJwcm9jZXNzSW5wdXRQYXRoIiwiZW5jY29kaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidGVzdCIsInByb2Nlc3NUZXh0IiwicHJvY2Vzc092ZXJsYXkiLCJvdmVybGF5IiwiZW50cmllcyIsInBvc2l0aW9uIiwidGltaW5nIiwidGV4dE92ZXJsYXkiLCJ0ZXh0IiwiZW5jb2RpbmciLCJwdXNoIiwiaW1hZ2VPdmVybGF5IiwiaW5wdXQiLCJ2aWRlb092ZXJsYXkiLCJzdWJ0aXRsZU92ZXJsYXkiLCJzb2xpZENvbG9yT3ZlcmxheSIsImNvbG9yIiwic3RhcnQiLCJlbmQiLCJwYXJzZWRUcmFuc2Zvcm1zIiwibCIsInBhcnNlZFRyYW5zZm9ybVN0ZXAiLCJyYXdTdHJpbmciLCJ0cmFuc2Zvcm1LZXkiLCJERUZBVUxUX0RFVklDRV9CUkVBS1BPSU5UUyIsIkRFRkFVTFRfSU1BR0VfQlJFQUtQT0lOVFMiLCJzaXplcyIsImRldmljZUJyZWFrcG9pbnRzIiwiaW1hZ2VCcmVha3BvaW50cyIsInNvcnRlZERldmljZUJyZWFrcG9pbnRzIiwic29ydCIsImEiLCJiIiwic29ydGVkSW1hZ2VCcmVha3BvaW50cyIsImFsbEJyZWFrcG9pbnRzIiwiY2FuZGlkYXRlcyIsImRlc2NyaXB0b3JLaW5kIiwiY29tcHV0ZUNhbmRpZGF0ZVdpZHRocyIsImV4cGxpY2l0V2lkdGgiLCJzaXplc0F0dHIiLCJidWlsZFVSTCIsInciLCJzcmNTZXQiLCJmaW5hbFNpemVzIiwicGFyYW1zIiwidndUb2tlbnMiLCJtYXRjaCIsInZ3UGVyY2VudHMiLCJ0IiwicGFyc2VJbnQiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIm1pbiIsIm1pblJlcXVpcmVkUHgiLCJmaWx0ZXIiLCJuZWFyZXN0IiwiZmluZCIsIm4iLCJ1bmlxdWUiLCJTZXQiLCJfX3Jlc3QiLCJzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIlN1cHByZXNzZWRFcnJvciIsInN1cHByZXNzZWQiLCJjcmVhdGVDb250ZXh0IiwicHJvcHMiLCJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImNoaWxkcmVuIiwibG9hZGVyIiwicHJvY2VzcyIsIndhcm4iLCJjb250ZXh0VmFsdWVzIiwidXNlQ29udGV4dCIsIl9hIiwiYXNzaWduIiwidW5vcHRpbWl6ZWQiLCJyZXNwb25zaXZlIiwibm9uSUtQYXJhbXMiLCJmaW5hbFRyYW5zZm9ybWF0aW9uIiwicHJvcHNUcmFuc2Zvcm1hdGlvbiIsInBhcnNlZFF1YWxpdHkiLCJOdW1iZXIiLCJpc05hTiIsIk5leHRJbWFnZSIsImZpbmFsU3JjV2l0aG91dFRyYW5zZm9ybWF0aW9uIiwic3JjV2l0aG91dFVybEVuZHBvaW50IiwiZmluYWxTcmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@imagekit/next/dist/client/index-esm.js\n");

/***/ })

};
;